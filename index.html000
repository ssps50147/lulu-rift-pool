<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ÈòøÈπøÈπøÊé•Êé•Ê®Ç</title>

  <!-- LIFF SDK -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

  <style>
    :root{
      --bg1:#ffd6e7;
      --bg2:#fff4f9;
      --card:#ffffffcc;
      --text:#111;
    }
    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      background: linear-gradient(180deg,var(--bg1),var(--bg2));
      overflow:hidden;
      touch-action: none;
    }

    #game{
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* HUD */
    #hud{
      position:absolute;
      top: 14px;
      left: 14px;
      right: 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      z-index: 10;
      pointer-events:none;
    }

    .pill{
      pointer-events:auto;
      background: var(--card);
      border-radius: 18px;
      padding: 10px 14px;
      font-weight: 800;
      box-shadow: 0 10px 30px rgba(0,0,0,.10);
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--text);
      user-select:none;
      -webkit-user-select:none;
    }

    .pill.small{
      font-weight:700;
      padding: 10px 12px;
    }

    #titlePill{
      max-width: 46vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    #welcomePill{
      flex:1;
      justify-content:flex-start;
      max-width: 48vw;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      font-weight: 800;
    }

    #btnRestartTop{
      pointer-events:auto;
      border:none;
      background:#fff;
      border-radius: 18px;
      padding: 10px 14px;
      font-weight: 800;
      box-shadow: 0 10px 30px rgba(0,0,0,.10);
      cursor:pointer;
    }

    /* Player (ÈòøÈπøÈπø) */
    #player{
      position:absolute;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      width: 78px;
      height: 78px;
      border-radius: 20px;
      background: rgba(255,255,255,.88);
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 46px;
      user-select:none;
      -webkit-user-select:none;
      z-index: 3;
    }

    /* Falling items */
    .item{
      position:absolute;
      width: 54px;
      height: 54px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 38px;
      user-select:none;
      -webkit-user-select:none;
      filter: drop-shadow(0 10px 12px rgba(0,0,0,.12));
      will-change: transform;
      z-index: 2;
    }

    /* Ground */
    #ground{
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      height: 18px;
      background: rgba(0,0,0,.05);
      z-index: 1;
    }

    /* GameOver overlay */
    #gameover{
      display:none;
      position:absolute;
      inset:0;
      background: rgba(255,255,255,.82);
      z-index: 999;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    #gameoverCard{
      width:min(520px, 92vw);
      background:#fff;
      border-radius: 24px;
      padding: 18px;
      box-shadow: 0 18px 50px rgba(0,0,0,.16);
      display:flex;
      flex-direction:column;
      gap: 10px;
      text-align:center;
    }
    #gameoverTitle{
      font-size: 28px;
      font-weight: 900;
    }
    #finalScore{
      font-size: 20px;
      font-weight: 800;
    }
    .btn{
      border:none;
      border-radius: 18px;
      padding: 12px 14px;
      font-size: 16px;
      font-weight: 900;
      cursor:pointer;
    }
    .btn.primary{
      background:#111;
      color:#fff;
    }
    .btn.secondary{
      background:#fff;
      border:1px solid #ddd;
      color:#111;
    }
    #shareHint{
      font-size: 12px;
      opacity: .75;
      margin-top: 2px;
      word-break: break-word;
    }

    /* Leaderboard */
    #lb{
      margin-top: 10px;
      text-align:left;
      background: #fafafa;
      border-radius: 18px;
      padding: 12px;
      border: 1px solid #eee;
    }
    #lbTitle{
      font-weight: 900;
      margin-bottom: 8px;
    }
    .lbRow{
      display:flex;
      justify-content:space-between;
      padding: 6px 8px;
      border-radius: 12px;
      background:#fff;
      border:1px solid #f0f0f0;
      margin-bottom: 6px;
      font-weight: 700;
      font-size: 14px;
    }
    .muted{
      opacity:.7;
      font-size:12px;
      margin-top: 4px;
      line-height: 1.35;
    }

    /* Volume panel (left side, vertical sliders) */
    #volPanel{
      position:absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 20;
      pointer-events: auto;
      user-select:none;
      -webkit-user-select:none;
    }
    #volCard{
      background: rgba(255,255,255,.88);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 12px 34px rgba(0,0,0,.12);
      border-radius: 18px;
      padding: 10px 10px 12px;
      width: 58px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }
    .volTitle{
      font-weight: 900;
      font-size: 12px;
      opacity: .85;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      letter-spacing: 1px;
    }
    .volGroup{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
    }
    .volLabel{
      font-size: 12px;
      font-weight: 900;
    }
    input[type="range"].vertical{
      -webkit-appearance: slider-vertical;
      writing-mode: bt-lr;
      width: 22px;
      height: 120px;
      accent-color: #111;
    }
    #btnVolToggle{
      border:none;
      cursor:pointer;
      background:#111;
      color:#fff;
      font-weight: 900;
      border-radius: 14px;
      padding: 8px 10px;
      width: 58px;
      box-shadow: 0 10px 22px rgba(0,0,0,.14);
      margin-bottom: 8px;
    }
    .hide{
      display:none !important;
    }

    /* Small helper to avoid accidental scrolling on iOS */
    *{ -webkit-tap-highlight-color: transparent; }
  </style>
</head>

<body>
  <div id="game">
    <div id="hud">
      <div class="pill" id="titlePill">ü¶í ÈòøÈπøÈπøÊé•Êé•Ê®Ç</div>

      <div class="pill" id="welcomePill">ÈπøÁ≤â‰Ω†Â•ΩÔΩûÊ∫ñÂÇôÊé•Êé•Ê®ÇÔºÅ</div>

      <div class="pill small" id="scorePill">ÂàÜÊï∏Ôºö<span id="score">0</span></div>
      <div class="pill small" id="lifePill">ÂëΩÔºö<span id="lives">3</span> ‚ù§Ô∏è</div>

      <button id="btnRestartTop" title="ÈáçÊñ∞ÈñãÂßã">ÈáçÊñ∞ÈñãÂßã</button>
    </div>

    <!-- Volume panel -->
    <div id="volPanel" aria-label="volume panel">
      <button id="btnVolToggle" title="È°ØÁ§∫/Êî∂ÂêàÈü≥Èáè">Èü≥Èáè</button>
      <div id="volCard">
        <div class="volTitle">Ë™øÊï¥</div>

        <div class="volGroup">
          <div class="volLabel">ü´ß</div>
          <input id="sfxVol" class="vertical" type="range" min="0" max="100" value="35" />
        </div>

        <div class="volGroup">
          <div class="volLabel">üéµ</div>
          <input id="bgmVol" class="vertical" type="range" min="0" max="100" value="28" />
        </div>
      </div>
    </div>

    <div id="player" aria-label="player">ü¶í</div>
    <div id="ground"></div>

    <!-- Game Over Overlay -->
    <div id="gameover">
      <div id="gameoverCard">
        <div id="gameoverTitle">Game Over</div>
        <div id="finalScore">ÂàÜÊï∏Ôºö0</div>

        <button class="btn primary" id="btnShare">ÂàÜ‰∫´ÊàêÁ∏æÂà∞ LINE</button>
        <button class="btn secondary" id="btnRestart">ÈáçÊñ∞ÈñãÂßã</button>
        <div id="shareHint"></div>

        <div id="lb">
          <div id="lbTitle">üèÜ ÊéíË°åÊ¶úÔºàÊú¨Ê©üÔºâ</div>
          <div id="lbList"></div>
          <div class="muted">‚Äª ÁõÆÂâçÁÇ∫ÂêåË£ùÁΩÆ/ÂêåÁÄèË¶ΩÂô®‰øùÂ≠ò„ÄÇË¶ÅÂÖ®È´îÊéíË°åÊ¶úÈúÄÂæåÁ´ØÔºà‰πãÂæå‰πüÂèØ‰ª•ÂÜçÂπ´‰Ω†Âä†Ôºâ„ÄÇ</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /**********************
     *  Ë®≠ÂÆöÔºöÂ°´‰Ω†ÁöÑ LIFF ID
     **********************/
    const LIFF_ID = "2008825801-LXHTWx5N";

    /**********************
     *  ÈÅäÊà≤ÁãÄÊÖã
     **********************/
    const game = document.getElementById("game");
    const playerEl = document.getElementById("player");
    const scoreEl = document.getElementById("score");
    const livesEl = document.getElementById("lives");
    const welcomePill = document.getElementById("welcomePill");

    const btnRestartTop = document.getElementById("btnRestartTop");
    const gameoverEl = document.getElementById("gameover");
    const finalScoreEl = document.getElementById("finalScore");
    const btnRestart = document.getElementById("btnRestart");
    const btnShare = document.getElementById("btnShare");
    const shareHint = document.getElementById("shareHint");

    const volCard = document.getElementById("volCard");
    const btnVolToggle = document.getElementById("btnVolToggle");
    const sfxVolEl = document.getElementById("sfxVol");
    const bgmVolEl = document.getElementById("bgmVol");

    let W = window.innerWidth;
    let H = window.innerHeight;

    let playerX = W * 0.5;
    const playerW = 78;
    const playerH = 78;
    const itemW = 54;
    const itemH = 54;

    let score = 0;
    let lives = 3;

    let running = true;
    let lastT = performance.now();
    let lastSpawn = 0;

    let spawnInterval = 900; // ms, gets faster
    let speedBase = 220;     // px/sec, gets faster
    const items = [];

    let playerName = "ÈπøÁ≤â";
    let inLiff = false;

    // Combo for pitch up (good catches)
    let combo = 0;

    /**********************
     *  Â∑•ÂÖ∑ÔºöÈö®Ê©ü
     **********************/
    function rand(min, max){ return Math.random() * (max - min) + min; }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    /**********************
     *  WebAudioÔºöÈü≥Êïà & BGMÔºàÊüîÂíå„ÄÅËºïÂø´Ôºâ
     **********************/
    const AudioSys = (() => {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();

      const master = ctx.createGain();
      master.gain.value = 1.0;
      master.connect(ctx.destination);

      const sfx = ctx.createGain();
      const bgm = ctx.createGain();
      sfx.connect(master);
      bgm.connect(master);

      // gentle limiting to avoid harshness
      const comp = ctx.createDynamicsCompressor();
      comp.threshold.value = -18;
      comp.knee.value = 18;
      comp.ratio.value = 3;
      comp.attack.value = 0.008;
      comp.release.value = 0.12;
      master.disconnect();
      master.connect(comp);
      comp.connect(ctx.destination);

      // default volumes (can be changed by sliders)
      let sfxVol = 0.35;
      let bgmVol = 0.28;
      sfx.gain.value = sfxVol;
      bgm.gain.value = bgmVol;

      function setSfxVol(v){
        sfxVol = clamp(v, 0, 1);
        sfx.gain.value = sfxVol;
      }
      function setBgmVol(v){
        bgmVol = clamp(v, 0, 1);
        bgm.gain.value = bgmVol;
      }

      // bubble pop: two quick sine blips + tiny noise "po"
      function playBubblePop(pitchFactor = 1){
        const now = ctx.currentTime;

        // main blip
        const o1 = ctx.createOscillator();
        const g1 = ctx.createGain();
        o1.type = "sine";
        const base = 520 * pitchFactor;
        o1.frequency.setValueAtTime(base, now);
        o1.frequency.exponentialRampToValueAtTime(base * 1.35, now + 0.05);
        g1.gain.setValueAtTime(0.001, now);
        g1.gain.exponentialRampToValueAtTime(0.22, now + 0.01);
        g1.gain.exponentialRampToValueAtTime(0.001, now + 0.09);

        o1.connect(g1);
        g1.connect(sfx);

        // secondary blip (rounder Q ÂΩàÊÑü)
        const o2 = ctx.createOscillator();
        const g2 = ctx.createGain();
        o2.type = "triangle";
        o2.frequency.setValueAtTime(base * 0.66, now);
        o2.frequency.exponentialRampToValueAtTime(base * 0.9, now + 0.05);
        g2.gain.setValueAtTime(0.001, now);
        g2.gain.exponentialRampToValueAtTime(0.14, now + 0.012);
        g2.gain.exponentialRampToValueAtTime(0.001, now + 0.10);

        o2.connect(g2);
        g2.connect(sfx);

        // tiny noise "po"
        const noiseBuf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.06), ctx.sampleRate);
        const data = noiseBuf.getChannelData(0);
        for(let i=0;i<data.length;i++){
          data[i] = (Math.random()*2-1) * (1 - i/data.length);
        }
        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuf;
        const nf = ctx.createBiquadFilter();
        nf.type = "highpass";
        nf.frequency.value = 850;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.001, now);
        ng.gain.exponentialRampToValueAtTime(0.10, now + 0.01);
        ng.gain.exponentialRampToValueAtTime(0.001, now + 0.06);

        noise.connect(nf);
        nf.connect(ng);
        ng.connect(sfx);

        o1.start(now); o1.stop(now + 0.11);
        o2.start(now); o2.stop(now + 0.12);
        noise.start(now); noise.stop(now + 0.065);
      }

      function playHitBad(){
        const now = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "square";
        o.frequency.setValueAtTime(180, now);
        o.frequency.exponentialRampToValueAtTime(110, now + 0.12);
        g.gain.setValueAtTime(0.001, now);
        g.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.16);
        o.connect(g); g.connect(sfx);
        o.start(now); o.stop(now + 0.18);
      }

      // Soft upbeat BGM: simple arpeggio + pad (very light)
      let bgmTimer = null;
      let bgmNodes = [];
      const scale = [0, 2, 4, 7, 9]; // major pentatonic
      let step = 0;

      function startBgm(){
        if(bgmTimer) return;
        const tempo = 108; // relaxed upbeat
        const beat = 60 / tempo; // seconds per quarter
        const tick = beat / 2; // eighth notes

        // gentle pad drone
        const pad = ctx.createOscillator();
        const pad2 = ctx.createOscillator();
        const padG = ctx.createGain();
        const padF = ctx.createBiquadFilter();
        pad.type = "sine";
        pad2.type = "sine";
        pad.frequency.value = 220;
        pad2.frequency.value = 220 * 2;
        padG.gain.value = 0.05;
        padF.type = "lowpass";
        padF.frequency.value = 1200;
        pad.connect(padG);
        pad2.connect(padG);
        padG.connect(padF);
        padF.connect(bgm);

        pad.start();
        pad2.start();
        bgmNodes.push({pad, pad2, padG, padF});

        bgmTimer = setInterval(() => {
          const now = ctx.currentTime;
          // arpeggio note
          const root = 261.63; // C4
          const octave = (step % 16 < 8) ? 0 : 12;
          const deg = scale[step % scale.length] + octave;
          const freq = root * Math.pow(2, deg/12);

          const o = ctx.createOscillator();
          const g = ctx.createGain();
          const f = ctx.createBiquadFilter();

          o.type = "triangle";
          o.frequency.setValueAtTime(freq, now);

          f.type = "lowpass";
          f.frequency.setValueAtTime(1500, now);

          g.gain.setValueAtTime(0.0001, now);
          g.gain.exponentialRampToValueAtTime(0.09, now + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, now + tick * 0.9);

          o.connect(f);
          f.connect(g);
          g.connect(bgm);

          o.start(now);
          o.stop(now + tick);

          step++;
        }, Math.floor(tick * 1000));
      }

      function stopBgm(){
        if(bgmTimer){
          clearInterval(bgmTimer);
          bgmTimer = null;
        }
        // stop pad nodes
        bgmNodes.forEach(n => {
          try{ n.pad.stop(); }catch(e){}
          try{ n.pad2.stop(); }catch(e){}
        });
        bgmNodes = [];
      }

      function resume(){
        if(ctx.state !== "running"){
          ctx.resume().catch(()=>{});
        }
      }

      return { ctx, resume, setSfxVol, setBgmVol, playBubblePop, playHitBad, startBgm, stopBgm };
    })();

    // sliders -> audio volumes (persist)
    const VOL_KEY = "alulu_vol_v1";
    function loadVol(){
      try{
        const raw = localStorage.getItem(VOL_KEY);
        if(!raw) return null;
        return JSON.parse(raw);
      }catch(e){
        return null;
      }
    }
    function saveVol(sfx, bgm){
      localStorage.setItem(VOL_KEY, JSON.stringify({ sfx, bgm }));
    }

    function applyVolFromUI(){
      const sfx = clamp(Number(sfxVolEl.value)/100, 0, 1);
      const bgm = clamp(Number(bgmVolEl.value)/100, 0, 1);
      AudioSys.setSfxVol(sfx);
      AudioSys.setBgmVol(bgm);
      saveVol(sfxVolEl.value, bgmVolEl.value);
    }

    const savedVol = loadVol();
    if(savedVol){
      if(typeof savedVol.sfx !== "undefined") sfxVolEl.value = String(savedVol.sfx);
      if(typeof savedVol.bgm !== "undefined") bgmVolEl.value = String(savedVol.bgm);
    }
    applyVolFromUI();

    sfxVolEl.addEventListener("input", applyVolFromUI);
    bgmVolEl.addEventListener("input", applyVolFromUI);

    btnVolToggle.addEventListener("click", (e)=>{
      e.stopPropagation();
      volCard.classList.toggle("hide");
    });

    /**********************
     *  Áâ©ÂìÅÔºöÂ•ΩÁâ©(üíé) + Â£ûÁâ©(üçé)
     **********************/
    function spawnItem(){
      const el = document.createElement("div");
      el.className = "item";

      const good = Math.random() < 0.55;
      el.textContent = good ? "üíé" : "üçé";

      const x = rand(12, W - itemW - 12);
      const y = -70;

      el.style.transform = `translate(${x}px, ${y}px)`;
      game.appendChild(el);

      const speed = speedBase + rand(-30, 90);
      items.push({ el, x, y, speed, good });
    }

    /**********************
     *  Á¢∞Êíû
     **********************/
    function intersects(ax, ay, aw, ah, bx, by, bw, bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    /**********************
     *  HUD Êõ¥Êñ∞
     **********************/
    function updateHUD(){
      scoreEl.textContent = String(score);
      livesEl.textContent = String(lives);
    }

    /**********************
     *  ÊéíË°åÊ¶úÔºöÊú¨Ê©ü localStorage
     **********************/
    const LB_KEY = "alulu_catch_lb_v1";

    function loadLeaderboard(){
      try{
        const raw = localStorage.getItem(LB_KEY);
        return raw ? JSON.parse(raw) : [];
      }catch(e){
        return [];
      }
    }
    function saveLeaderboard(list){
      localStorage.setItem(LB_KEY, JSON.stringify(list));
    }
    function addToLeaderboard(name, score){
      const list = loadLeaderboard();
      list.push({ name, score, ts: Date.now() });
      list.sort((a,b)=> b.score - a.score);
      const top = list.slice(0, 10);
      saveLeaderboard(top);
      return top;
    }
    function renderLeaderboard(list){
      const box = document.getElementById("lbList");
      box.innerHTML = "";
      if(!list.length){
        box.innerHTML = `<div class="muted">ÈÇÑÊ≤íÊúâÁ¥ÄÈåÑÔºåÂø´Áï∂Á¨¨‰∏ÄÂêçÔºÅ</div>`;
        return;
      }
      list.forEach((r, i)=>{
        const row = document.createElement("div");
        row.className = "lbRow";
        row.innerHTML = `<div>${i+1}. ${escapeHtml(r.name || "ÈπøÁ≤â")}</div><div>${r.score}</div>`;
        box.appendChild(row);
      });
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
      }[m]));
    }

    /**********************
     *  LIFF ÂàùÂßãÂåñÔºàÊäìÂêçÂ≠óÔºâ
     **********************/
    async function initLIFF(){
      try{
        await liff.init({ liffId: LIFF_ID });
        inLiff = !!liff.isInClient && liff.isInClient();

        // ÈúÄË¶Å scope: profile + openidÔºàËã•‰Ω†ÊúâË®≠ÂÆöÔºâ
        if (liff.isLoggedIn && !liff.isLoggedIn()) {
          // Âú®Â§ñÈÉ®ÁÄèË¶ΩÂô®ÊúÉË∑≥ÁôªÂÖ•ÔºõÂú® LINE ÂÖßÈÄöÂ∏∏Â∑≤ÁôªÂÖ•
          liff.login();
          return;
        }

        try{
          const profile = await liff.getProfile();
          if(profile && profile.displayName){
            playerName = profile.displayName;
            welcomePill.textContent = `ÈπøÁ≤â ${playerName}ÔΩûÊ∫ñÂÇôÊé•Êé•Ê®ÇÔºÅ`;
          }
        }catch(e){
          welcomePill.textContent = "ÈπøÁ≤â‰Ω†Â•ΩÔΩûÊ∫ñÂÇôÊé•Êé•Ê®ÇÔºÅ";
        }
      }catch(e){
        inLiff = false;
        welcomePill.textContent = "ÈπøÁ≤â‰Ω†Â•ΩÔΩûÊ∫ñÂÇôÊé•Êé•Ê®ÇÔºÅ";
      }
    }

    /**********************
     *  ÂàÜ‰∫´ÊàêÁ∏æÔºàLINE ÂÖßÔºösendMessagesÔºâ
     *  ÈúÄË¶Å scope: chat_message.write
     **********************/
    async function shareScoreToLINE(score){
      const text = `ü¶í ÈòøÈπøÈπøÊé•Êé•Ê®Ç\nÈπøÁ≤â ${playerName} ÁöÑÊàêÁ∏æÔºö${score} ÂàÜÔºÅ\n‰Ω†‰πü‰æÜÊåëÊà∞ÁúãÁúãÔΩû`;
      shareHint.textContent = "";

      try{
        if(window.liff && liff.isInClient && liff.isInClient() && liff.sendMessages){
          await liff.sendMessages([{ type:"text", text }]);
          shareHint.textContent = "‚úÖ Â∑≤ÈÄÅÂá∫Âà∞ËÅäÂ§©ÂÆ§ÔºÅ";
          return;
        }
      }catch(e){
        // fall through
      }

      // fallback: copy to clipboard
      try{
        await navigator.clipboard.writeText(text);
        shareHint.textContent = "üìã Â∑≤Ë§áË£ΩÂàÜ‰∫´ÊñáÂ≠óÔºàÂèØË≤ºÂà∞ LINEÔºâ";
      }catch(e){
        shareHint.textContent = text; // show the text as last resort
      }
    }

    /**********************
     *  Áé©ÂÆ∂ÁßªÂãïÔºàÊªëÈº†/Ëß∏ÊéßÔºâ
     **********************/
    function setPlayerX(x){
      playerX = clamp(x, playerW/2 + 8, W - playerW/2 - 8);
      playerEl.style.left = playerX + "px";
    }

    // Pointer move within game
    function onPointerMove(e){
      if(!running) return;
      const x = e.clientX;
      setPlayerX(x);
    }

    // also allow drag / touch
    game.addEventListener("pointerdown", (e)=>{
      AudioSys.resume();
      AudioSys.startBgm();
      onPointerMove(e);
    }, {passive:true});

    game.addEventListener("pointermove", onPointerMove, {passive:true});

    // keyboard (desktop)
    const keys = { left:false, right:false };
    window.addEventListener("keydown", (e)=>{
      if(e.key === "ArrowLeft") keys.left = true;
      if(e.key === "ArrowRight") keys.right = true;
      if(e.key === " "){
        AudioSys.resume();
        AudioSys.startBgm();
      }
    });
    window.addEventListener("keyup", (e)=>{
      if(e.key === "ArrowLeft") keys.left = false;
      if(e.key === "ArrowRight") keys.right = false;
    });

    /**********************
     *  ÈÅäÊà≤ÊµÅÁ®ã
     **********************/
    function resetGame(){
      // clear items
      items.forEach(it => { try{ it.el.remove(); }catch(e){} });
      items.length = 0;

      score = 0;
      lives = 3;
      combo = 0;

      running = true;
      lastSpawn = 0;
      spawnInterval = 900;
      speedBase = 220;

      updateHUD();
      gameoverEl.style.display = "none";
      shareHint.textContent = "";

      setPlayerX(W * 0.5);

      // start audio on first interaction; here we don't force resume
    }

    function gameOver(){
      running = false;
      finalScoreEl.textContent = `ÂàÜÊï∏Ôºö${score}`;

      // leaderboard
      const top = addToLeaderboard(playerName, score);
      renderLeaderboard(top);

      gameoverEl.style.display = "flex";
    }

    function adjustDifficulty(){
      // gradually faster
      const s = score;
      spawnInterval = clamp(900 - s * 6, 340, 900);
      speedBase = clamp(220 + s * 3, 220, 520);
    }

    function tick(t){
      const dt = (t - lastT) / 1000;
      lastT = t;

      // keyboard movement
      if(running){
        let dx = 0;
        if(keys.left) dx -= 520 * dt;
        if(keys.right) dx += 520 * dt;
        if(dx !== 0) setPlayerX(playerX + dx);
      }

      if(running){
        // spawn
        lastSpawn += dt * 1000;
        if(lastSpawn >= spawnInterval){
          lastSpawn = 0;
          spawnItem();
          adjustDifficulty();
        }

        // player rect
        const px = playerX - playerW/2;
        const py = H - 22 - playerH;

        // update items
        for(let i = items.length - 1; i >= 0; i--){
          const it = items[i];
          it.y += it.speed * dt;

          // fall
          it.el.style.transform = `translate(${it.x}px, ${it.y}px)`;

          // collision
          if(intersects(px, py, playerW, playerH, it.x, it.y, itemW, itemH)){
            // remove
            try{ it.el.remove(); }catch(e){}
            items.splice(i, 1);

            if(it.good){
              score += 1;
              combo += 1;

              // pitch up with combo (cap) and keep not too sharp
              const pf = 1 + Math.min(combo, 18) * 0.03;
              AudioSys.resume();
              AudioSys.playBubblePop(pf);

            }else{
              lives -= 1;
              combo = 0;
              AudioSys.resume();
              AudioSys.playHitBad();
              if(lives <= 0){
                updateHUD();
                gameOver();
                break;
              }
            }
            updateHUD();
            continue;
          }

          // missed (hit ground)
          if(it.y > H - 18){
            try{ it.el.remove(); }catch(e){}
            items.splice(i, 1);

            if(it.good){
              // miss good -> lose life + reset combo
              lives -= 1;
              combo = 0;
              AudioSys.resume();
              AudioSys.playHitBad();
              updateHUD();
              if(lives <= 0){
                gameOver();
                break;
              }
            }else{
              // miss bad -> reward a tiny bit
              score += 1;
              combo = Math.max(0, combo - 1);
              AudioSys.resume();
              // small soft pop (lower pitch)
              AudioSys.playBubblePop(0.92);
              updateHUD();
            }
          }
        }
      }

      requestAnimationFrame(tick);
    }

    /**********************
     *  Ë¶ñÁ™óÂ§ßÂ∞èËÆäÊõ¥
     **********************/
    function onResize(){
      W = window.innerWidth;
      H = window.innerHeight;
      setPlayerX(playerX);
    }
    window.addEventListener("resize", onResize);

    /**********************
     *  Á∂ÅÂÆöÊåâÈàï
     **********************/
    btnRestartTop.addEventListener("click", ()=>{
      AudioSys.resume();
      AudioSys.startBgm();
      resetGame();
    });

    btnRestart.addEventListener("click", ()=>{
      AudioSys.resume();
      AudioSys.startBgm();
      resetGame();
    });

    btnShare.addEventListener("click", async ()=>{
      AudioSys.resume();
      await shareScoreToLINE(score);
    });

    /**********************
     *  ÂàùÂßã
     **********************/
    (async function boot(){
      // initial player position
      setPlayerX(playerX);

      // load lb
      renderLeaderboard(loadLeaderboard());

      // init liff (name + share ability)
      initLIFF();

      // start loop
      requestAnimationFrame((t)=>{
        lastT = t;
        requestAnimationFrame(tick);
      });

      // start BGM only after first user interaction (browser policy)
      // We'll also resume/start on pointerdown and restart buttons.
    })();
  </script>
</body>
</html>
