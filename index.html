<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>è£‚ç¸«æ°´æ± ï¼šé¹¿ç²‰æ’ˆæ’ˆç¥­</title>
  <style>
    :root{
      --panel: rgba(255,255,255,0.10);
      --txt: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --shadow: 0 12px 28px rgba(0,0,0,0.35);
    }
    html,body{
      margin:0;height:100%;
      background: radial-gradient(1200px 800px at 20% 10%, #1b2a5c 0%, #0b1020 55%, #060914 100%);
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      overflow:hidden;
    }
    #gameWrap{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    canvas{ width:100vw; height:100vh; display:block; }

    /* HUD */
    #hud{ position:fixed; inset:0; pointer-events:none; }
    .chip{
      display:inline-flex; align-items:center; gap:10px;
      padding:10px 14px; border-radius:999px;
      background: var(--panel);
      box-shadow: var(--shadow);
      border:1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      font-weight:800;
      letter-spacing:0.2px;
    }
    #topLeft{ position:absolute; left:14px; top:14px; display:flex; gap:10px; flex-wrap:wrap; }
    #topRight{ position:absolute; right:14px; top:14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    #bottomLeft{ position:absolute; left:14px; bottom:14px; display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; }
    #bottomRight{ position:absolute; right:14px; bottom:14px; display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }

    .btn{
      pointer-events:auto;
      cursor:pointer;
      padding:12px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.08));
      border:1px solid rgba(255,255,255,0.12);
      box-shadow: var(--shadow);
      color:var(--txt);
      font-weight:900;
      display:inline-flex; align-items:center; gap:10px;
      user-select:none;
      transition: transform .08s ease;
    }
    .btn:active{ transform: translateY(1px) scale(0.99); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(126,231,255,0.28), rgba(126,231,255,0.12));
      border-color: rgba(126,231,255,0.35);
    }
    .btn.tiny{ padding:10px 12px; border-radius: 12px; font-weight:900; }

    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding: 9px 12px; border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border:1px solid rgba(255,255,255,0.12);
      font-weight:900;
      letter-spacing:0.2px;
    }

    /* Volume controls */
    .volBox{
      pointer-events:auto;
      display:flex; flex-direction:column; gap:8px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      min-width: 220px;
    }
    .volRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:900;
      color: rgba(255,255,255,0.88);
      font-size: 12.5px;
    }
    .volRow span{ color: rgba(255,255,255,0.78); font-weight:900; }
    .volRow .val{ min-width: 32px; text-align:right; color: rgba(255,255,255,0.86); }
    input[type="range"]{
      width:100%;
      accent-color: rgba(126,231,255,0.95);
    }

    /* Portrait lock */
    #rotateLock{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: radial-gradient(900px 600px at 50% 20%, rgba(126,231,255,0.10), rgba(0,0,0,0.78));
      z-index:50;
      text-align:center;
      padding:24px;
    }
    #rotateLock .card{
      width:min(560px, 92vw);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 22px;
      padding: 20px 18px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    #rotateLock h2{ margin:0 0 10px 0; font-size: 22px; }
    #rotateLock p{ margin: 8px 0; color: var(--muted); line-height: 1.6; font-weight:800; }
    #rotateLock .icon{ font-size: 40px; margin-bottom: 8px; opacity: 0.95; }

    /* Modal */
    #modal{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index:40;
      background: rgba(0,0,0,0.55);
      padding: 18px;
    }
    #modal .panel{
      width: min(760px, 92vw);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
      transform: scale(0.75);
      transform-origin:center;
    }
    #modal .head{
      padding: 16px 18px;
      display:flex; align-items:center; justify-content:space-between;
      background: rgba(255,255,255,0.06);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      gap: 12px;
      flex-wrap: wrap;
    }
    #modal .head .title{ display:flex; flex-direction:column; gap:2px; }
    #modal .head h1{ margin:0; font-size: 20px; letter-spacing:0.3px; }
    #modal .head .sub{ color: var(--muted); font-weight:800; font-size: 12.5px; }
    #modal .body{ padding: 16px 18px 18px; }
    #modal .body p{ margin: 10px 0; color: var(--muted); line-height: 1.7; font-weight:800; }
    #modal .body ul{ margin: 10px 0 0 18px; padding:0; color: var(--muted); line-height: 1.75; font-weight:800;}
    #modal .foot{
      padding: 14px 18px 18px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      flex-wrap:wrap;
    }
    #modal .foot .hint{
      color: rgba(255,255,255,0.78);
      font-weight:900;
      font-size: 12.5px;
      opacity: 0.95;
    }
    .kbd{
      display:inline-flex; align-items:center; justify-content:center;
      padding: 2px 8px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.25);
      font-weight:900;
      font-size: 12px;
      color: rgba(255,255,255,0.88);
    }

    /* Leaderboard */
    #lb{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index:45;
      background: rgba(0,0,0,0.55);
      padding: 18px;
    }
    #lb .panel{
      width: min(760px, 92vw);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.16);
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
      overflow:hidden;
    }
    #lb .head{
      padding: 16px 18px;
      display:flex; align-items:center; justify-content:space-between;
      background: rgba(255,255,255,0.06);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    #lb h2{ margin:0; font-size: 18px; }
    #lb .body{ padding: 14px 18px 18px; }
    table{
      width:100%;
      border-collapse: collapse;
      overflow:hidden;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
    }
    th,td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      font-weight:900;
      font-size: 13px;
      color: rgba(255,255,255,0.90);
    }
    th{ text-align:left; color: rgba(255,255,255,0.78); }
    tr:last-child td{ border-bottom:none; }
    .right{ text-align:right; }
    .muted{ color: var(--muted); font-weight:900; }
  </style>

  <!-- âœ… LIFF æ”¯æ´ï¼ˆåªéœ€æ”¹ä¸€è¡Œ LIFF_IDï¼‰ -->
  <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
</head>

<body>
  <div id="gameWrap">
    <canvas id="c"></canvas>
  </div>

  <!-- Portrait lock -->
  <div id="rotateLock">
    <div class="card">
      <div class="icon">ğŸ“±â†”ï¸</div>
      <h2>è«‹æ©«å‘éŠç©</h2>
      <p>ã€Šè£‚ç¸«æ°´æ± ï¼šé¹¿ç²‰æ’ˆæ’ˆç¥­ã€‹å¼·åˆ¶æ©«å‘éŠç©ã€‚ç›´å‘æ™‚ä¸å¯é–‹å§‹ã€‚</p>
      <p class="muted">è«‹å°‡æ‰‹æ©Ÿè½‰ç‚ºæ©«å‘ï¼Œæˆ–èª¿æ•´ç€è¦½å™¨è¦–çª—æ¯”ä¾‹ã€‚</p>
    </div>
  </div>

  <!-- Tutorial modal -->
  <div id="modal">
    <div class="panel">
      <div class="head">
        <div class="title">
          <h1>è£‚ç¸«æ°´æ± ï¼šé¹¿ç²‰æ’ˆæ’ˆç¥­</h1>
          <div class="sub" id="eventSub">60 ç§’æ’ˆå–æŒ‘æˆ°ï½œæŒ‰ä½ä¸‹ç¶²æ’ˆç¢ç‰‡ï¼é‡‘é­šå¾—åˆ†</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <div class="badge" id="eventBadge">ğŸ«§ ä¼‘é–’æ¨¡å¼</div>
          <div class="btn tiny" id="btnSoundHint" title="å»ºè­°é–‹å•ŸéŸ³é‡æ›´å¥½ç©">ğŸ”Š å»ºè­°é–‹éŸ³é‡</div>
        </div>
      </div>

      <div class="body">
        <p>ç©æ³•ï¼š<b>æŒ‰ä½ï¼ˆæ»‘é¼ /æ‰‹æŒ‡ï¼‰</b>åœ¨æ°´æ± ä¸‹ç¶²ï¼Œé¬†é–‹æ”¶ç¶²ã€‚æ”¶ç¶²æ™‚è‹¥ç¢°åˆ°ç‰©ä»¶å°±èƒ½æ’ˆèµ·å¾—åˆ†ï¼</p>
        <ul>
          <li>â±ï¸ åªæœ‰ <b>60 ç§’</b>ï¼Œç¯€å¥è¦å¿«ä½†åˆ¥äº‚ï¼š<b>æ’ˆåˆ°æ‰ç®—</b>ã€‚</li>
          <li>ğŸ§© ç¢ç‰‡ï¼šåŸºç¤å¾—åˆ†ï¼›ğŸŸ é‡‘é­šï¼šè¼ƒé«˜å¾—åˆ†ï¼›ğŸŒ™ é‡‘è‰²é‡‘é­šï¼šå¤œé–“ç‰¹åˆ¥åˆ†æ•¸ã€‚</li>
          <li>ğŸ”¥ é€£æ“Šï¼šé€£çºŒæˆåŠŸæ’ˆèµ·æœƒæé«˜é€£æ“Šï¼›è‹¥ä¸€è¶Ÿç©ºç¶²å°±æœƒæ–·é€£æ“Šã€‚</li>
          <!-- âœ… ä¾ä½ è¦æ±‚ï¼šç´…æ¡†å…§å…©å¥å·²å®Œå…¨ç§»é™¤ï¼Œä¸å†å‡ºç¾åœ¨æ•™å­¸è¦–çª— -->
        </ul>
        <p class="muted">å°æç¤ºï¼šé–‹å•ŸéŸ³é‡éŠç©æœƒæ›´æœ‰è¶£ âœ¨</p>
      </div>

      <div class="foot">
        <div class="hint">æ“ä½œï¼š<span class="kbd">æŒ‰ä½</span> ä¸‹ç¶²ï½œ<span class="kbd">é¬†é–‹</span> æ”¶ç¶²ï½œ<span class="kbd">R</span> é‡æ–°é–‹å§‹</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
          <div class="btn" id="btnLeaderboard">ğŸ† ä»Šæ—¥æ’è¡Œæ¦œ</div>
          <div class="btn primary" id="btnStart">é–‹å§‹éŠæˆ²</div>
        </div>
      </div>
    </div>

    <!-- å³ä¸‹è§’å¿«é€Ÿé–‹å§‹ -->
    <div id="quickStartWrap" style="position:fixed; right:14px; bottom:14px; z-index:60;">
      <div class="btn primary" id="btnQuickStart">âš¡ å¿«é€Ÿé–‹å§‹</div>
    </div>
  </div>

  <!-- Leaderboard -->
  <div id="lb">
    <div class="panel">
      <div class="head">
        <h2>ğŸ† ä»Šæ—¥æ’è¡Œæ¦œ</h2>
        <div class="btn" id="btnCloseLB">é—œé–‰</div>
      </div>
      <div class="body">
        <div class="muted" style="margin-bottom:10px;">åªä¿ç•™ã€Œä»Šå¤©ã€çš„è³‡æ–™ï¼ˆè·¨æ—¥æœƒè‡ªå‹•æ­¸é›¶ï¼‰ã€‚</div>
        <table>
          <thead>
            <tr>
              <th style="width:64px;">åæ¬¡</th>
              <th>åç¨±</th>
              <th class="right">åˆ†æ•¸</th>
              <th class="right">æ¨¡å¼</th>
            </tr>
          </thead>
          <tbody id="lbBody"></tbody>
        </table>
        <div class="muted" style="margin-top:12px;">ä½ å¯ä»¥åœ¨çµç®—æ™‚è¼¸å…¥æš±ç¨±ï¼ˆLIFF æœƒå„ªå…ˆä½¿ç”¨ LINE åç¨±ï¼‰ã€‚</div>
      </div>
    </div>
  </div>

  <!-- HUD -->
  <div id="hud">
    <div id="topLeft">
      <div class="chip">â±ï¸ <span id="timeLeft">60.0</span>s</div>
      <div class="chip">ğŸ åˆ†æ•¸ <span id="score">0</span></div>
      <div class="chip">ğŸ”¥ é€£æ“Š <span id="combo">0</span></div>
    </div>

    <div id="topRight">
      <div class="badge" id="modeBadge">ğŸ«§ ä¼‘é–’æ¨¡å¼</div>
      <div class="chip">å€ç‡ x<span id="mult">1.0</span></div>
    </div>

    <div id="bottomLeft">
      <div class="btn tiny" id="btnMute">ğŸ”ˆ éŸ³æ•ˆï¼šé–‹</div>
      <div class="btn tiny" id="btnBgm">ğŸµ BGMï¼šé–‹</div>

      <!-- âœ… æ–°å¢ï¼šå¯æ‰‹å‹•èª¿æ•´éŸ³é‡ -->
      <div class="volBox" aria-label="volume controls">
        <div class="volRow">
          <span>ğŸ«§ é»æ“ŠéŸ³æ•ˆéŸ³é‡</span>
          <span class="val" id="sfxVal">50</span>
        </div>
        <input id="sfxVol" type="range" min="0" max="100" step="1" value="50" />

        <div class="volRow" style="margin-top:2px;">
          <span>ğŸµ ç’°å¢ƒ BGM éŸ³é‡</span>
          <span class="val" id="bgmVal">25</span>
        </div>
        <input id="bgmVol" type="range" min="0" max="100" step="1" value="25" />
      </div>
    </div>

    <div id="bottomRight">
      <div class="btn tiny" id="btnHow">ğŸ“– æ•™å­¸</div>
      <div class="btn tiny" id="btnRestart">ğŸ” é‡é–‹</div>
      <div class="btn tiny" id="btnLB2">ğŸ† æ’è¡Œæ¦œ</div>
    </div>
  </div>

<script>
(() => {
  /**********************
   * LIFF (one-line ID)
   **********************/
  const LIFF_ID = "2008825801-LXHTWx5N"; // âœ… åªéœ€æ”¹é€™ä¸€è¡Œ
  let liffProfile = null;

  async function initLIFF(){
    try{
      if(!window.liff || !LIFF_ID || LIFF_ID.includes("YOUR_LIFF_ID")) return;
      await window.liff.init({ liffId: LIFF_ID });
      if(window.liff.isLoggedIn()){
        try{ liffProfile = await window.liff.getProfile(); }catch(e){}
      }
    }catch(e){}
  }
  initLIFF();

  /**********************
   * Helpers
   **********************/
  const $ = (id) => document.getElementById(id);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function todayKey(){
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  }
  function nowEvent(){
    const h = new Date().getHours();
    return { frenzy: (h>=12 && h<14), night: (h>=19 && h<21), hour:h };
  }

  /**********************
   * Audio (no external files)
   * âœ… æ–°å¢ï¼šæ‰‹å‹•å¯èª¿æ•´ SFX / BGM éŸ³é‡ï¼ˆä¸¦è¨˜ä½è¨­å®šï¼‰
   **********************/
  let audioCtx = null;
  let sfxEnabled = true;
  let bgmEnabled = true;

  let sfxGainNode = null;
  let bgmGainNode = null;

  // slider 0~100 -> gain mapping (conservative, not noisy)
  const SFX_GAIN_MAX = 0.22;   // æœ€é«˜ä»ä¸æœƒå¤ªåµ
  const BGM_GAIN_MAX = 0.06;   // âœ… æ¯”ä½ åŸæœ¬è¦ºå¾—å¤§è²çš„æ›´ä½ä¸Šé™

  function loadVolSettings(){
    const sfx = Number(localStorage.getItem("rr_sfx_vol") ?? "50");
    const bgm = Number(localStorage.getItem("rr_bgm_vol") ?? "25"); // âœ… é è¨­æ›´å°è²
    return {
      sfx: clamp(isFinite(sfx)?sfx:50, 0, 100),
      bgm: clamp(isFinite(bgm)?bgm:25, 0, 100),
    };
  }
  function saveVolSettings(sfx, bgm){
    localStorage.setItem("rr_sfx_vol", String(sfx));
    localStorage.setItem("rr_bgm_vol", String(bgm));
  }
  function sliderToGain(val01_100, maxGain){
    const t = clamp(val01_100, 0, 100) / 100;
    // éç·šæ€§æ›²ç·šï¼šå°éŸ³é‡æ›´ç´°ç·»
    const curved = Math.pow(t, 1.6);
    return curved * maxGain;
  }

  function ensureAudio(){
    if(audioCtx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    sfxGainNode = audioCtx.createGain();
    bgmGainNode = audioCtx.createGain();
    sfxGainNode.connect(audioCtx.destination);
    bgmGainNode.connect(audioCtx.destination);
  }

  function applyVolumes(){
    const sfxV = Number($("sfxVol").value);
    const bgmV = Number($("bgmVol").value);

    $("sfxVal").textContent = String(sfxV);
    $("bgmVal").textContent = String(bgmV);

    saveVolSettings(sfxV, bgmV);

    if(!audioCtx || !sfxGainNode || !bgmGainNode) return;

    const sfxGain = sfxEnabled ? sliderToGain(sfxV, SFX_GAIN_MAX) : 0.0001;
    const bgmGain = bgmEnabled ? sliderToGain(bgmV, BGM_GAIN_MAX) : 0.0001;

    sfxGainNode.gain.value = sfxGain;
    bgmGainNode.gain.value = bgmGain;
  }

  function applyAudioToggles(){
    $("btnMute").textContent = sfxEnabled ? "ğŸ”ˆ éŸ³æ•ˆï¼šé–‹" : "ğŸ”‡ éŸ³æ•ˆï¼šé—œ";
    $("btnBgm").textContent  = bgmEnabled ? "ğŸµ BGMï¼šé–‹" : "ğŸµ BGMï¼šé—œ";
    if(bgmEnabled) startBGM(); else stopBGM();
    applyVolumes();
  }

  // Bubble SFX (combo pitch up)
  function playBubble(comboLevel){
    if(!sfxEnabled) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;

    const c = clamp(comboLevel, 0, 40);
    const base = 220 + c * 12;
    const f1 = base * (1.0 + Math.random()*0.04);
    const f2 = base * 1.65;

    const o1 = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const lp = audioCtx.createBiquadFilter();

    o1.type = "sine";
    o2.type = "triangle";
    o1.frequency.setValueAtTime(f1, t0);
    o2.frequency.setValueAtTime(f2, t0);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(1400, t0);
    lp.Q.value = 0.9;

    // envelope (quiet by design; final loudness is controlled by slider)
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.55, t0 + 0.012);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);

    o1.frequency.exponentialRampToValueAtTime(f1 * 0.75, t0 + 0.09);
    o2.frequency.exponentialRampToValueAtTime(f2 * 0.80, t0 + 0.10);

    o1.connect(lp); o2.connect(lp);
    lp.connect(g);
    g.connect(sfxGainNode);

    o1.start(t0); o2.start(t0);
    o1.stop(t0 + 0.14); o2.stop(t0 + 0.14);
  }

  // Procedural BGM
  let bgmTimer = null;
  let bgmNodes = [];
  let bgmStep = 0;

  function stopBGM(){
    if(bgmTimer){ clearInterval(bgmTimer); bgmTimer = null; }
    for(const n of bgmNodes){
      try{ n.stop && n.stop(); }catch(e){}
      try{ n.disconnect && n.disconnect(); }catch(e){}
    }
    bgmNodes = [];
  }

  function startBGM(){
    if(!bgmEnabled) return;
    ensureAudio();
    if(bgmTimer) return;

    const bpm = 122;
    const stepMs = (60_000 / bpm) / 2; // 1/8

    const prog = [
      { root: 0,  type: "maj" },
      { root: 5,  type: "maj" },
      { root: 7,  type: "maj" },
      { root: 9,  type: "min" },
    ];
    const scale = [0,2,4,7,9,12,14,16];

    const midiToHz = (m)=> 440 * Math.pow(2, (m-69)/12);
    const chordTones = (rootMidi, type) => (type==="min" ? [0,3,7] : [0,4,7]).map(x=>rootMidi+x);

    function pluck(freq, dur=0.13, when=audioCtx.currentTime){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const hp = audioCtx.createBiquadFilter();

      o.type = "triangle";
      o.frequency.setValueAtTime(freq, when);

      hp.type = "highpass";
      hp.frequency.setValueAtTime(120, when);
      hp.Q.value = 0.6;

      g.gain.setValueAtTime(0.0001, when);
      g.gain.exponentialRampToValueAtTime(0.22, when + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, when + dur);

      o.connect(hp); hp.connect(g); g.connect(bgmGainNode);
      o.start(when); o.stop(when + dur + 0.02);
      bgmNodes.push(o,g,hp);
    }

    function pad(freq, dur=0.55, when=audioCtx.currentTime){
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter();

      o.type = "sine";
      o.frequency.setValueAtTime(freq, when);

      lp.type = "lowpass";
      lp.frequency.setValueAtTime(900, when);
      lp.Q.value = 0.5;

      g.gain.setValueAtTime(0.0001, when);
      g.gain.exponentialRampToValueAtTime(0.12, when + 0.05);
      g.gain.exponentialRampToValueAtTime(0.0001, when + dur);

      o.connect(lp); lp.connect(g); g.connect(bgmGainNode);
      o.start(when); o.stop(when + dur + 0.03);
      bgmNodes.push(o,g,lp);
    }

    bgmTimer = setInterval(() => {
      const t = audioCtx.currentTime;
      const bar = Math.floor(bgmStep / 16);
      const p = prog[bar % prog.length];

      const rootMidi = 60 + p.root;
      const tones = chordTones(rootMidi, p.type);

      if(bgmStep % 8 === 0){
        for(const m of tones) pad(midiToHz(m - 12), 0.62, t);
      }

      const should = (bgmStep % 2 === 0) && Math.random() < 0.82;
      if(should){
        const pick = scale[(bgmStep/2 + (Math.random()<0.25?1:0)) % scale.length | 0];
        const note = rootMidi + pick + (Math.random()<0.18?12:0);
        pluck(midiToHz(note), 0.14 + Math.random()*0.06, t);
      }

      bgmStep = (bgmStep + 1) % 64;
      if(bgmNodes.length > 220) bgmNodes.splice(0, 130);
    }, stepMs);
  }

  /**********************
   * Canvas / Game State
   **********************/
  const canvas = $("c");
  const ctx = canvas.getContext("2d");

  let W=1280, H=720, DPR=1;
  function resize(){
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.max(640, Math.floor(window.innerWidth));
    H = Math.max(360, Math.floor(window.innerHeight));
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  function isLandscape(){ return window.innerWidth >= window.innerHeight; }
  function updateRotateLock(){
    const locked = !isLandscape();
    $("rotateLock").style.display = locked ? "flex" : "none";
    if(locked){
      if(state.phase === "playing") state.phase = "paused_by_rotate";
    }else{
      if(state.phase === "paused_by_rotate"){
        state.phase = "playing";
        state.lastTs = performance.now();
      }
    }
  }
  window.addEventListener("resize", updateRotateLock);
  window.addEventListener("orientationchange", updateRotateLock);

  const state = {
    phase: "boot",
    tLeft: 60.0,
    score: 0,
    combo: 0,
    bestCombo: 0,
    mult: 1.0,
    modeName: "ä¼‘é–’æ¨¡å¼",
    modeIcon: "ğŸ«§",
    modeTag: "DAY",
    event: nowEvent(),
    lastTs: 0,
    pointerDown: false,
    pointerX: 0,
    net: { x:0, y:0, targetY:0, phase:"idle", radius:48, speed:920, depth:0.70, caughtThisRun:0 },
    pool: { x:0, y:0, w:0, h:0 },
    items: [],
    spawnAcc: 0,
    ripples: [],
    particles: [],
  };

  function setModeUI(){
    state.event = nowEvent();
    if(state.event.night){
      state.modeName = "é‡‘é­šä¹‹å¤œ"; state.modeIcon = "ğŸŒ™"; state.modeTag = "NIGHT";
    }else if(state.event.frenzy){
      state.modeName = "è£‚ç¸«æš´èµ°"; state.modeIcon = "ğŸ”¥"; state.modeTag = "FRENZY";
    }else{
      state.modeName = "ä¼‘é–’æ¨¡å¼"; state.modeIcon = "ğŸ«§"; state.modeTag = "DAY";
    }
    $("modeBadge").textContent = `${state.modeIcon} ${state.modeName}`;
    $("eventBadge").textContent = `${state.modeIcon} ${state.modeName}`;
    $("eventSub").textContent = "60 ç§’æ’ˆå–æŒ‘æˆ°ï½œæŒ‰ä½ä¸‹ç¶²æ’ˆç¢ç‰‡ï¼é‡‘é­šå¾—åˆ†";
  }

  function poolLayout(){
    const pad = 14;
    const topHud = 74;
    const bottomHud = 74;
    const x = pad;
    const y = pad + topHud;
    const w = W - pad*2;
    const h = H - (pad + topHud) - (pad + bottomHud);
    state.pool = { x, y, w, h };
    state.net.x = x + w/2;
    state.net.y = y + 14;
    state.net.targetY = y + h * state.net.depth;
    state.net.radius = clamp(w * 0.035, 34, 62);
  }
  poolLayout();
  window.addEventListener("resize", poolLayout);

  function updateHUD(){
    $("timeLeft").textContent = state.tLeft.toFixed(1);
    $("score").textContent = Math.floor(state.score);
    $("combo").textContent = state.combo;
    $("mult").textContent = state.mult.toFixed(1);
  }

  function resetGame(){
    setModeUI();
    state.phase = "ready";
    state.tLeft = 60.0;
    state.score = 0;
    state.combo = 0;
    state.bestCombo = 0;
    state.mult = 1.0;
    state.items = [];
    state.spawnAcc = 0;
    state.ripples = [];
    state.particles = [];
    state.net.phase = "idle";
    state.net.caughtThisRun = 0;
    updateHUD();
  }

  function startGame(){
    if(!isLandscape()){ updateRotateLock(); return; }
    ensureAudio();
    if(audioCtx.state === "suspended"){ audioCtx.resume().catch(()=>{}); }

    setModeUI();
    state.phase = "playing";
    state.tLeft = 60.0;
    state.score = 0;
    state.combo = 0;
    state.bestCombo = 0;
    state.items = [];
    state.spawnAcc = 0;
    state.ripples = [];
    state.particles = [];
    state.net.phase = "idle";
    state.net.caughtThisRun = 0;
    state.lastTs = performance.now();

    startBGM();
    applyAudioToggles();
    updateHUD();
  }

  function endGame(){
    state.phase = "ended";
    const info = getPlayerInfo();
    saveScoreToday({
      name: info.name,
      score: state.score,
      mode: state.modeName,
      tag: state.modeTag,
      bestCombo: state.bestCombo,
      at: Date.now()
    });
    showLeaderboard();
  }

  /**********************
   * Leaderboard (today only)
   **********************/
  function lbStorageKey(){ return `rr_leaderboard_${todayKey()}`; }

  function loadTodayLB(){
    const key = lbStorageKey();
    let arr = [];
    try{
      arr = JSON.parse(localStorage.getItem(key) || "[]");
      if(!Array.isArray(arr)) arr = [];
    }catch(e){ arr = []; }
    // cleanup other days
    try{
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith("rr_leaderboard_") && k !== key) localStorage.removeItem(k);
      }
    }catch(e){}
    return arr;
  }

  function saveScoreToday(entry){
    const key = lbStorageKey();
    const arr = loadTodayLB();
    arr.push(entry);
    arr.sort((a,b)=>b.score - a.score);
    localStorage.setItem(key, JSON.stringify(arr.slice(0, 20)));
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  function renderLB(){
    const arr = loadTodayLB();
    const tbody = $("lbBody");
    tbody.innerHTML = "";
    if(arr.length === 0){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td colspan="4" class="muted">ä»Šå¤©é‚„æ²’æœ‰æˆç¸¾ï¼Œå¿«å»æ’ˆä¸€æŠŠï¼</td>`;
      tbody.appendChild(tr);
      return;
    }
    arr.forEach((e, idx) => {
      const modeLabel = e.tag==="NIGHT" ? "ğŸŒ™ å¤œé–“" : (e.tag==="FRENZY" ? "ğŸ”¥ æš´èµ°" : "ğŸ«§ ç™½å¤©");
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${idx+1}</td>
        <td>${escapeHtml(e.name || "é¹¿ç²‰")}</td>
        <td class="right">${Math.floor(e.score)}</td>
        <td class="right">${modeLabel}</td>
      `;
      tbody.appendChild(tr);
    });
  }
  function showLeaderboard(){ renderLB(); $("lb").style.display = "flex"; }
  function hideLeaderboard(){ $("lb").style.display = "none"; }

  function getPlayerInfo(){
    const last = localStorage.getItem("rr_last_name") || "";
    let name = (liffProfile && liffProfile.displayName) ? liffProfile.displayName : last;
    if(!name) name = prompt("è¼¸å…¥æš±ç¨±ï¼ˆæ’è¡Œæ¦œç”¨ï¼‰", "é¹¿ç²‰") || "é¹¿ç²‰";
    name = name.trim().slice(0, 12) || "é¹¿ç²‰";
    localStorage.setItem("rr_last_name", name);
    return { name };
  }

  /**********************
   * Input
   **********************/
  function setPointerFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (("touches" in e) ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (("touches" in e) ? e.touches[0].clientY : e.clientY) - rect.top;
    return { x: clamp(x, 0, W), y: clamp(y, 0, H) };
  }

  function pointerDown(e){
    if(state.phase !== "playing") return;
    if(!isLandscape()) return;
    e.preventDefault();
    const p = setPointerFromEvent(e);
    state.pointerDown = true;
    state.pointerX = p.x;

    if(state.net.phase === "idle"){
      state.net.phase = "down";
      state.net.caughtThisRun = 0;
      state.net.x = clamp(p.x, state.pool.x+20, state.pool.x+state.pool.w-20);
      state.net.y = state.pool.y + 12;
      state.net.targetY = state.pool.y + state.pool.h * state.net.depth;
      addRipple(state.net.x, state.pool.y + 18, 0.6);
    }
  }

  function pointerMove(e){
    if(state.phase !== "playing") return;
    if(!state.pointerDown) return;
    const p = setPointerFromEvent(e);
    state.pointerX = p.x;
    state.net.x = clamp(p.x, state.pool.x+20, state.pool.x+state.pool.w-20);
  }

  function pointerUp(){
    if(state.phase !== "playing") return;
    if(!state.pointerDown) return;
    state.pointerDown = false;
    if(state.net.phase === "down"){
      state.net.phase = "up";
      addRipple(state.net.x, state.net.y, 0.9);
    }
  }

  canvas.addEventListener("mousedown", pointerDown);
  window.addEventListener("mousemove", pointerMove);
  window.addEventListener("mouseup", pointerUp);

  canvas.addEventListener("touchstart", pointerDown, { passive:false });
  canvas.addEventListener("touchmove", pointerMove, { passive:false });
  canvas.addEventListener("touchend", pointerUp, { passive:false });
  canvas.addEventListener("touchcancel", pointerUp, { passive:false });

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if(k === "r"){ resetGame(); hideModal(); startGame(); }
    if(k === "m"){ sfxEnabled = !sfxEnabled; applyAudioToggles(); }
    if(k === "b"){ bgmEnabled = !bgmEnabled; applyAudioToggles(); }
  });

  /**********************
   * Spawning / scoring
   **********************/
  function spawnRatePerSec(){
    let r = 2.7;
    if(state.event.frenzy) r *= 1.65;
    if(state.event.night) r *= 1.25;
    return r;
  }
  function scoreMultiplier(){
    let m = 1.0 + clamp(state.combo, 0, 30) * 0.03;
    if(state.event.frenzy) m *= 1.35;
    return m;
  }
  function spawnItem(){
    const { x, y, w } = state.pool;
    const crackX = x + w*0.5 + (Math.random()-0.5)*w*0.28;
    const spawnY = y + 8 + Math.random()*10;

    let type = "fragment";
    let pFish = state.event.night ? 0.26 : 0.18;
    if(state.event.frenzy) pFish += 0.06;

    const roll = Math.random();
    if(roll < pFish){
      type = state.event.night && Math.random() < 0.52 ? "goldfish" : "fish";
    }

    const baseSpeed = 35 + Math.random()*55;
    const drift = (Math.random()-0.5)*22;

    const size = (type==="fragment") ? (10 + Math.random()*10) : (14 + Math.random()*10);
    const val = (type==="fragment") ? 80 : (type==="fish" ? 160 : 260);

    state.items.push({
      type,
      x: crackX, y: spawnY,
      vx: drift, vy: baseSpeed,
      size, val,
      wobble: Math.random()*Math.PI*2,
      caught: false,
    });
  }

  function tryCatch(){
    const net = state.net;
    const r = net.radius;
    let caught = 0;

    for(const it of state.items){
      if(it.caught) continue;
      const dx = it.x - net.x;
      const dy = it.y - net.y;
      if(Math.hypot(dx, dy) < r * 0.92){
        it.caught = true;
        caught++;
        net.caughtThisRun++;
        const m = scoreMultiplier();
        state.mult = m;
        state.score += it.val * m;
        state.combo += 1;
        state.bestCombo = Math.max(state.bestCombo, state.combo);

        playBubble(state.combo);
        addParticles(it.x, it.y, it.type);
      }
    }
    return caught;
  }

  /**********************
   * FX
   **********************/
  function addRipple(x,y, strength=1){
    state.ripples.push({ x, y, r: 6, a: 0.9*strength, speed: 220*strength });
  }
  function addParticles(x,y,type){
    const n = type==="fragment" ? 8 : 12;
    for(let i=0;i<n;i++){
      state.particles.push({
        x, y,
        vx: (Math.random()-0.5)*220,
        vy: (Math.random()-0.6)*240,
        life: 0.55 + Math.random()*0.35,
        t: 0,
        type
      });
    }
  }

  /**********************
   * Rendering
   **********************/
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawBackground(){
    const { frenzy, night } = state.event;
    const g = ctx.createLinearGradient(0, 0, 0, H);
    if(night){ g.addColorStop(0, "#0a0f18"); g.addColorStop(1, "#1c1b2a"); }
    else if(frenzy){ g.addColorStop(0, "#1a1430"); g.addColorStop(1, "#0a0d18"); }
    else{ g.addColorStop(0, "#0b1020"); g.addColorStop(1, "#070a14"); }
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.globalAlpha = night ? 0.28 : 0.18;
    ctx.fillStyle = night ? "#ffd36a" : "#7ee7ff";
    for(let i=0;i<70;i++){
      const x = (i*97 + (performance.now()*0.01)) % W;
      const y = (i*53) % H;
      const s = 1 + (i%5)*0.5;
      ctx.fillRect(x, y, s, s);
    }
    ctx.restore();
  }

  function drawPool(){
    const { x,y,w,h } = state.pool;
    const { frenzy, night } = state.event;

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.strokeStyle = "rgba(255,255,255,0.16)";
    ctx.lineWidth = 2;
    roundRect(x, y, w, h, 22);
    ctx.fill(); ctx.stroke();

    const wg = ctx.createLinearGradient(0, y, 0, y+h);
    if(night){ wg.addColorStop(0, "rgba(255,211,106,0.14)"); wg.addColorStop(1, "rgba(80,40,12,0.18)"); }
    else if(frenzy){ wg.addColorStop(0, "rgba(255,106,122,0.12)"); wg.addColorStop(1, "rgba(40,20,60,0.20)"); }
    else{ wg.addColorStop(0, "rgba(126,231,255,0.14)"); wg.addColorStop(1, "rgba(20,60,90,0.18)"); }

    ctx.fillStyle = wg;
    roundRect(x+8, y+8, w-16, h-16, 18);
    ctx.fill();

    // crack
    const cx = x + w*0.5;
    ctx.save();
    ctx.translate(cx, y+18);
    ctx.globalAlpha = 0.9;
    ctx.strokeStyle = night ? "rgba(255,211,106,0.75)" : (frenzy ? "rgba(255,106,122,0.70)" : "rgba(126,231,255,0.70)");
    ctx.lineWidth = 3.5;
    ctx.lineCap = "round";
    ctx.beginPath();
    const len = w*0.18;
    ctx.moveTo(-len*0.55, 0);
    ctx.lineTo(-len*0.22, 8);
    ctx.lineTo(0, -4);
    ctx.lineTo(len*0.18, 10);
    ctx.lineTo(len*0.55, 2);
    ctx.stroke();
    ctx.globalAlpha = 0.22; ctx.lineWidth = 14; ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawFragment(x,y,s){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(Math.sin((x+y)*0.01 + performance.now()*0.002)*0.6);
    ctx.globalAlpha = 0.92;

    const night = state.event.night;
    ctx.fillStyle = night ? "rgba(255,211,106,0.90)" : "rgba(126,231,255,0.92)";
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1.2;

    ctx.beginPath();
    ctx.moveTo(-s*0.6, -s*0.2);
    ctx.lineTo(0, -s*0.75);
    ctx.lineTo(s*0.7, -s*0.05);
    ctx.lineTo(s*0.15, s*0.75);
    ctx.lineTo(-s*0.75, s*0.25);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(s*0.15, -s*0.25, s*0.25, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawFish(x,y,s,isGold){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(Math.sin((x+y)*0.01 + performance.now()*0.002)*0.2);

    const body = isGold ? "rgba(255,211,106,0.92)" : "rgba(170,255,210,0.90)";
    const fin  = isGold ? "rgba(255,174,70,0.90)" : "rgba(120,240,200,0.85)";
    const eye  = "rgba(0,0,0,0.55)";

    ctx.globalAlpha = 0.96;
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.ellipse(0, 0, s*0.85, s*0.55, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = fin;
    ctx.beginPath();
    ctx.moveTo(-s*0.9, 0);
    ctx.lineTo(-s*1.35, -s*0.45);
    ctx.lineTo(-s*1.25, 0);
    ctx.lineTo(-s*1.35, s*0.45);
    ctx.closePath();
    ctx.fill();

    ctx.globalAlpha = 0.75;
    ctx.beginPath();
    ctx.moveTo(0, -s*0.1);
    ctx.quadraticCurveTo(s*0.15, -s*0.75, s*0.65, -s*0.2);
    ctx.closePath();
    ctx.fill();

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(s*0.38, -s*0.10, s*0.14, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = eye;
    ctx.beginPath();
    ctx.arc(s*0.42, -s*0.10, s*0.07, 0, Math.PI*2);
    ctx.fill();

    if(isGold && state.event.night){
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = `900 ${Math.floor(s*1.0)}px ui-sans-serif, system-ui`;
      ctx.textAlign = "center";
      ctx.fillText("ğŸŒ™", s*1.1, -s*0.65);
    }
    ctx.restore();
  }

  function drawItems(dt){
    for(const it of state.items){
      if(it.caught) continue;
      it.wobble += dt * 2.2;
      it.x += it.vx * dt + Math.sin(it.wobble) * 10 * dt;
      it.y += it.vy * dt;

      const { x,y,w,h } = state.pool;
      it.x = clamp(it.x, x+14, x+w-14);
      if(it.y > y + h + 30){
        it.y = y + 8;
        it.x = x + w*0.5 + (Math.random()-0.5)*w*0.28;
        it.vx = (Math.random()-0.5)*22;
        it.vy = 35 + Math.random()*55;
      }

      if(it.type === "fragment") drawFragment(it.x, it.y, it.size);
      else if(it.type === "fish") drawFish(it.x, it.y, it.size, false);
      else drawFish(it.x, it.y, it.size, true);
    }
  }

  function drawNet(dt){
    const net = state.net;
    const { x,y,w } = state.pool;

    if(net.phase === "down"){
      net.y += net.speed * dt;
      tryCatch();
      if(net.y >= net.targetY){
        net.y = net.targetY;
        if(!state.pointerDown) net.phase = "up";
      }
    }else if(net.phase === "up"){
      net.y -= net.speed * dt;
      tryCatch();
      if(net.y <= y + 12){
        net.y = y + 12;
        net.phase = "idle";
        if(net.caughtThisRun === 0){
          state.combo = 0;
          state.mult = scoreMultiplier();
        }
        net.caughtThisRun = 0;
      }
    }

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(net.x, y - 18);
    ctx.lineTo(net.x, net.y - net.radius*0.9);
    ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.strokeStyle = state.event.night ? "rgba(255,211,106,0.90)" : "rgba(126,231,255,0.90)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.ellipse(net.x, net.y, net.radius, net.radius*0.75, 0, 0, Math.PI*2);
    ctx.stroke();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "rgba(255,255,255,0.55)";
    ctx.lineWidth = 1;
    for(let a=0; a<Math.PI; a+=Math.PI/6){
      ctx.beginPath();
      ctx.moveTo(net.x, net.y);
      ctx.lineTo(net.x + Math.cos(a)*net.radius, net.y + Math.sin(a)*net.radius*0.75);
      ctx.stroke();
    }
    ctx.restore();

    if(net.phase === "idle" && state.phase==="playing"){
      const px = clamp(state.pointerX || (x+w/2), x+20, x+w-20);
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "rgba(255,255,255,0.7)";
      ctx.beginPath();
      ctx.arc(px, y+16, 8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawRipples(dt){
    for(const r of state.ripples){ r.r += r.speed * dt; r.a -= dt * 1.2; }
    state.ripples = state.ripples.filter(r=>r.a>0.02);
    ctx.save();
    for(const r of state.ripples){
      ctx.globalAlpha = r.a * 0.45;
      ctx.strokeStyle = state.event.night ? "rgba(255,211,106,0.85)" : "rgba(126,231,255,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(r.x, r.y, r.r, r.r*0.55, 0, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawParticles(dt){
    for(const p of state.particles){
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 420 * dt;
    }
    state.particles = state.particles.filter(p=>p.t < p.life);
    ctx.save();
    for(const p of state.particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = a * 0.8;
      let col = "rgba(126,231,255,0.9)";
      if(p.type === "fish") col = "rgba(180,255,220,0.9)";
      if(p.type === "goldfish") col = "rgba(255,211,106,0.95)";
      ctx.fillStyle = col;
      ctx.fillRect(p.x-2, p.y-2, 4, 4);
    }
    ctx.restore();
  }

  function drawEndOverlay(){
    if(state.phase !== "ended") return;
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "900 44px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC";
    ctx.textAlign = "center";
    ctx.fillText("æ™‚é–“åˆ°ï¼", W/2, H*0.45);
    ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC";
    ctx.fillStyle = "rgba(255,255,255,0.78)";
    ctx.fillText("å·²å¯«å…¥ä»Šæ—¥æ’è¡Œæ¦œ", W/2, H*0.45 + 34);
    ctx.restore();
  }

  /**********************
   * Main loop
   **********************/
  function tick(ts){
    requestAnimationFrame(tick);
    updateRotateLock();

    const dt = state.lastTs ? Math.min(0.033, (ts - state.lastTs)/1000) : 0;
    state.lastTs = ts;

    if(state.phase === "playing"){
      state.tLeft -= dt;
      if(state.tLeft <= 0){
        state.tLeft = 0;
        updateHUD();
        endGame();
      }
    }

    if(state.phase === "playing"){
      state.spawnAcc += dt * spawnRatePerSec();
      while(state.spawnAcc >= 1){ spawnItem(); state.spawnAcc -= 1; }
      if(state.items.length > 90) state.items.splice(0, state.items.length - 90);
      state.mult = scoreMultiplier();
      updateHUD();
    }

    drawBackground();
    drawPool();
    if(state.phase === "playing" || state.phase === "ended"){
      drawItems(dt);
      drawRipples(dt);
      drawParticles(dt);
      drawNet(dt);
    }else{
      drawRipples(dt);
      drawParticles(dt);
      drawNet(0);
    }
    drawEndOverlay();
  }
  requestAnimationFrame(tick);

  /**********************
   * UI flow
   **********************/
  function showModal(){ $("modal").style.display = "flex"; state.phase = "tutorial"; }
  function hideModal(){ $("modal").style.display = "none"; }

  $("btnStart").addEventListener("click", () => { hideModal(); resetGame(); startGame(); });
  $("btnQuickStart").addEventListener("click", () => { hideModal(); resetGame(); startGame(); });
  $("btnHow").addEventListener("click", () => { setModeUI(); showModal(); });

  $("btnLeaderboard").addEventListener("click", showLeaderboard);
  $("btnLB2").addEventListener("click", showLeaderboard);
  $("btnCloseLB").addEventListener("click", hideLeaderboard);
  $("btnRestart").addEventListener("click", () => { resetGame(); hideModal(); startGame(); });

  $("btnSoundHint").addEventListener("click", () => {
    ensureAudio();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    applyVolumes();
    playBubble(state.combo || 0);
  });

  $("btnMute").addEventListener("click", () => {
    ensureAudio();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    sfxEnabled = !sfxEnabled;
    applyAudioToggles();
    playBubble(state.combo || 0);
  });

  $("btnBgm").addEventListener("click", () => {
    ensureAudio();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    bgmEnabled = !bgmEnabled;
    applyAudioToggles();
  });

  $("lb").addEventListener("click", (e) => { if(e.target === $("lb")) hideLeaderboard(); });

  // âœ… sliders -> realtime volume change
  $("sfxVol").addEventListener("input", () => {
    ensureAudio();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    applyVolumes();
    // å°é è½ï¼ˆé¿å…ä¸€ç›´åµï¼Œåªæœ‰åœ¨èª¿æ•´åˆ°æŸäº›ä½ç½®æ‰ç™¼ä¸€é¡†ï¼‰
    if(Number($("sfxVol").value) % 10 === 0) playBubble(state.combo || 0);
  });
  $("bgmVol").addEventListener("input", () => {
    ensureAudio();
    if(audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    applyVolumes();
  });

  /**********************
   * Boot
   **********************/
  function boot(){
    // load saved vol to UI first
    const v = loadVolSettings();
    $("sfxVol").value = String(v.sfx);
    $("bgmVol").value = String(v.bgm);

    setModeUI();
    updateRotateLock();
    resetGame();

    // audio toggles + apply volumes (no sound until user gesture)
    applyAudioToggles();
    showModal();
  }
  boot();
})();
</script>
</body>
</html>
