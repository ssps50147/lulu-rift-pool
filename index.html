<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>è£‚ç¸«æ°´æ± ï¼šé¹¿ç²‰æ’ˆæ’ˆç¥­ï¼ˆLIFF ç‰ˆï¼‰</title>
  <style>
    :root{
      --card:rgba(255,255,255,.62);
      --ink:rgba(10,18,32,.86);
      --ink2:rgba(10,18,32,.62);
      --white:rgba(255,255,255,.92);
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --r: 18px;
    }
    html,body{
      height:100%;margin:0;
      background: radial-gradient(1200px 700px at 50% 20%, #1a325a 0%, #081225 55%, #050b16 100%);
      color:var(--white);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
    }
    .wrap{height:100%; display:grid; place-items:center; padding:14px;}
    .frame{
      position:relative;
      width:min(980px, 100%);
      aspect-ratio:16/9;
      max-height: calc(100vh - 28px);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      background: radial-gradient(circle at 50% 25%, #a7f3ff 0%, #2aa6ff 28%, #0b6ea8 55%, #063254 100%);
    }
    canvas{width:100%; height:100%; display:block; touch-action:none;}

    .hud{
      position:absolute; inset:14px 14px auto 14px;
      display:flex; gap:12px; align-items:stretch; flex-wrap:wrap;
      pointer-events:none;
    }
    .card{
      background: var(--card);
      color: var(--ink);
      border-radius: var(--r);
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.35);
      min-width: 180px;
    }
    .card b{font-weight:800}
    .row{display:flex; gap:10px; align-items:center; justify-content:space-between;}
    .sub{font-size:12px; color: var(--ink2); margin-top:4px; line-height:1.35;}
    .bar{height:10px; width: 180px; background: rgba(10,18,32,.10); border-radius: 999px; overflow:hidden; margin-top:8px;}
    .bar i{display:block;height:100%;width:100%; background: rgba(255,213,120,.95);}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      background: rgba(10,18,32,.10);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--ink2);
      margin-top:8px;
      flex-wrap:wrap;
    }

    .overlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      background: radial-gradient(900px 600px at 50% 30%, rgba(255,255,255,.22) 0%, rgba(0,0,0,.35) 55%, rgba(0,0,0,.55) 100%);
    }
    .panel{
      width: min(580px, 92%);
      background: rgba(255,255,255,.70);
      color: var(--ink);
      border-radius: 24px;
      padding: 18px 18px 16px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.4);
      backdrop-filter: blur(12px);
    }
    .title{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    h1{margin:0; font-size: 22px; letter-spacing: .2px;}
    .tag{font-size: 12px; color: var(--ink2); background: rgba(10,18,32,.08); padding:6px 10px; border-radius:999px;}
    .desc{margin: 10px 0 14px; color: var(--ink2); line-height: 1.6; font-size: 14px;}
    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top: 12px;}
    button{
      appearance:none; border:0; cursor:pointer;
      border-radius: 14px;
      padding: 11px 14px;
      font-weight: 800;
      background: rgba(10,18,32,.85);
      color: rgba(255,255,255,.92);
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
    }
    button.secondary{
      background: rgba(10,18,32,.10);
      color: var(--ink);
      font-weight: 700;
      box-shadow:none;
      border: 1px solid rgba(10,18,32,.12);
    }
    .small{font-size:12px; color: var(--ink2);}
    .rank{
      margin-top: 10px;
      background: rgba(10,18,32,.06);
      border-radius: 16px;
      padding: 10px 12px;
      border: 1px solid rgba(10,18,32,.06);
    }
    .rank h2{margin:0 0 8px; font-size: 14px; color: rgba(10,18,32,.75);}
    .rank ol{margin:0; padding-left: 18px; color: rgba(10,18,32,.72); font-size: 13px; line-height: 1.6;}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      background: rgba(255,255,255,.6);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(10,18,32,.10);
    }
    .toast{
      position:absolute; left: 16px; top: 86px;
      background: rgba(255,255,255,.72);
      color: rgba(10,18,32,.86);
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.45);
      backdrop-filter: blur(10px);
      max-width: min(760px, calc(100% - 32px));
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      opacity:0; transform: translateY(-6px);
      transition: opacity .18s ease, transform .18s ease;
      pointer-events:none;
      white-space: pre-line;
    }
    .toast.show{opacity:1; transform: translateY(0);}

    /* ===== LIFF-only top bar ===== */
    .liffbar{
      position:absolute;
      right: 14px;
      top: 14px;
      display:flex;
      gap:10px;
      z-index: 50;
      pointer-events:auto;
    }
    .liffbar button{
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      background: rgba(10,18,32,.72);
      color: rgba(255,255,255,.92);
      border: 1px solid rgba(255,255,255,.20);
      box-shadow: 0 10px 25px rgba(0,0,0,.22);
    }
    .hidden{display:none !important;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="frame">
    <!-- LIFF å°ˆç”¨ï¼šåªåœ¨ LINE App å…§é¡¯ç¤º -->
    <div class="liffbar hidden" id="liffBar">
      <button id="closeBtn" title="é—œé–‰ LIFF è¦–çª—">é—œé–‰</button>
    </div>

    <canvas id="c" width="1280" height="720"></canvas>

    <div class="hud" aria-hidden="true">
      <div class="card">
        <div class="row">
          <div>è£‚ç¸«æ”¶é›†ï¼š<b id="score">0</b></div>
          <div>â³ <b id="time">60</b>s</div>
        </div>
        <div class="sub">ä¸»è§’ï¼šå¾®å…‰ç¢ç‰‡ï½œæ•´é»å¯èƒ½ç™¼å¸ƒæ¢ç´¢æç¤ºä¸¦åˆ·æ–°æ•´é»å›è²</div>
        <div class="pill">
          é€£æ“Šï¼š<b id="combo">0</b>
          ç¨€æœ‰é‡‘é­šï¼š<b id="fishCount">0</b>
          ç¨±è™Ÿï¼š<b id="title">æ–°æ‰‹é¹¿ç²‰</b>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div>ç´™ç¶²è€ä¹…ï¼š<b id="durText">100</b></div>
          <div>ç ´ç¶²ï¼š<b id="breaks">0</b></div>
        </div>
        <div class="bar"><i id="durBar"></i></div>
        <div class="sub">æŒ‰ä½ä¸‹ç¶²æ’ˆèµ·ç‰©ä»¶æœƒè€—æï¼›è€ä¹…æ­¸é›¶æœƒç ´ï¼ˆè‡ªå‹•æ›æ–°ï¼‰</div>
      </div>
    </div>

    <div class="toast" id="toast"></div>

    <div class="overlay" id="overlay">
      <div class="panel" role="dialog" aria-modal="true">
        <div class="title">
          <h1>ğŸŒŒ è£‚ç¸«æ°´æ± ï¼šé¹¿ç²‰æ’ˆæ’ˆç¥­</h1>
          <div class="tag">LIFF å°ˆç”¨é—œé–‰éµ</div>
        </div>
        <div class="desc">
          ä½ æ˜¯é¹¿ç²‰ï¼æ’ˆèµ·ã€Œå¾®å…‰ç¢ç‰‡ã€æ”¶é›†ç·šç´¢ã€‚<br/>
          <b>å›è²ç¢ç‰‡</b>æœƒåˆ·å‡ºæ¢ç´¢æç¤ºï¼›<b>é‡‘é­š</b>æ˜¯ç¨€æœ‰é©šå–œã€‚<br/>
          ã€Œæ•´é»ï¼ˆxx:00ï¼‰ã€å‰ 10 ç§’å…§ï¼Œæœ‰æ©Ÿç‡ç™¼å¸ƒä¸€æ¬¡ç¥ç§˜æ¢ç´¢æç¤ºä¸¦åˆ·æ–°ã€Œæ•´é»å›è²ç¢ç‰‡ã€ã€‚
        </div>

        <div class="rank">
          <h2>ğŸ† æœ¬æ©Ÿæ’è¡Œæ¦œï¼ˆTop 5ï¼‰</h2>
          <ol id="rankList"></ol>
        </div>

        <div class="btns">
          <button id="startBtn">é–‹å§‹æ’ˆæ’ˆï¼</button>
          <button class="secondary" id="muteBtn">éŸ³æ•ˆï¼šé–‹</button>
          <button class="secondary" id="resetRankBtn">æ¸…ç©ºæ’è¡Œæ¦œ</button>
        </div>

        <div class="small" style="margin-top:10px;">
          æ“ä½œï¼šæ»‘é¼ /æ‰‹æŒ‡ç§»å‹•ç¶²å­ï¼Œ<b>æŒ‰ä½</b>ä¸‹ç¶²æ’ˆèµ·ã€‚<br/>
          éµç›¤ï¼š<span class="kbd">R</span> é‡é–‹ï¼ˆéŠæˆ²ä¸­å¯ç”¨ï¼‰
        </div>

        <div class="small" id="resultText" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>
</div>

<!-- LIFF SDKï¼ˆå¿…è¦ï¼‰ -->
<script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

<script>
(() => {
  // =========================
  // âœ… ä½ åªè¦æ”¹é€™ä¸€è¡Œï¼šå¡«å…¥ä½ çš„ LIFF ID
  // =========================
  const LIFF_ID = "PASTE_YOUR_LIFF_ID_HERE";

  // ===== LIFF: åµæ¸¬æ˜¯å¦åœ¨ LINE å…§é–‹å•Ÿï¼Œä¸¦é¡¯ç¤ºé—œé–‰æŒ‰éˆ• =====
  const liffBar = document.getElementById('liffBar');
  const closeBtn = document.getElementById('closeBtn');

  async function initLiffAndUi(){
    // æ²’å¡« LIFF_ID å°±ä¸åˆå§‹åŒ–ï¼ˆé¿å…å ±éŒ¯ï¼‰
    if(!window.liff || !LIFF_ID || LIFF_ID.includes("PASTE_")) return;

    try{
      await liff.init({ liffId: LIFF_ID });

      // åªåœ¨ LINE App å…§é¡¯ç¤ºé—œé–‰æŒ‰éˆ•
      if (liff.isInClient && liff.isInClient()) {
        liffBar.classList.remove('hidden');
      }

      closeBtn.addEventListener('click', ()=>{
        if (liff.isInClient && liff.isInClient()) {
          liff.closeWindow();
        }
      });
    }catch(e){
      // åˆå§‹åŒ–å¤±æ•—ä¹Ÿä¸å½±éŸ¿ä¸€èˆ¬ç€è¦½å™¨éŠç©
      console.warn("LIFF init failed:", e);
    }
  }
  initLiffAndUi();

  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // ===== UI =====
  const uiScore = document.getElementById('score');
  const uiTime = document.getElementById('time');
  const uiCombo = document.getElementById('combo');
  const uiFishCount = document.getElementById('fishCount');
  const uiTitle = document.getElementById('title');
  const uiDurText = document.getElementById('durText');
  const uiDurBar = document.getElementById('durBar');
  const uiBreaks = document.getElementById('breaks');

  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');
  const resetRankBtn = document.getElementById('resetRankBtn');
  const rankList = document.getElementById('rankList');
  const resultText = document.getElementById('resultText');
  const toast = document.getElementById('toast');

  // ===== Helpers =====
  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const dist2 = (ax,ay,bx,by)=> { const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

  // ===== Audio =====
  let audioOn = true;
  let actx = null;
  function beep(freq=440, dur=0.06, type="sine", gain=0.04){
    if(!audioOn) return;
    try{
      if(!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
      const o = actx.createOscillator();
      const g = actx.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(actx.destination);
      o.start();
      o.stop(actx.currentTime + dur);
    }catch(_){}
  }

  // ===== Leaderboard =====
  const LS_KEY = "lulu_rift_pool_rank_liff_onlyclose_v1";
  function loadRank(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(_){ return []; }
  }
  function saveRank(arr){
    try{ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }catch(_){}
  }
  function renderRank(){
    const arr = loadRank().slice(0,5);
    rankList.innerHTML = "";
    if(arr.length === 0){
      const li = document.createElement("li");
      li.textContent = "é‚„æ²’æœ‰ç´€éŒ„ï¼Œå¿«å»æ’ˆç¬¬ä¸€åï¼";
      rankList.appendChild(li);
      return;
    }
    for(const r of arr){
      const li = document.createElement("li");
      li.textContent = `${r.score} åˆ†ï¼ˆç ´ç¶² ${r.breaks} æ¬¡ï½œæœ€é«˜é€£æ“Š ${r.maxCombo}ï½œé‡‘é­š ${r.fishHits}ï¼‰`;
      rankList.appendChild(li);
    }
  }

  // ===== Toast =====
  let toastTimer = 0;
  function showToast(text){
    toast.textContent = text;
    toast.classList.add("show");
    toastTimer = 2.6;
  }

  // ===== Random Hourly Hint =====
  let lastHourlyKey = "";
  function hourlyKey(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    const h = String(d.getHours()).padStart(2,"0");
    return `${y}-${m}-${day} ${h}`;
  }
  const hourlyHintPool = [
    "ğŸ•³ï¸ æ•´é»æ¢ç´¢æç¤º\nè£‚ç¸«åœ¨å‘¼å¸ã€‚ç¢ç‰‡æœƒæ›´é è¿‘æ°´é¢ã€‚",
    "ğŸ›°ï¸ æ•´é»æ¢ç´¢æç¤º\nç³»çµ±æƒæä¸­â€¦é¹¿ç²‰è«‹ä¿æŒå†·éœã€‚",
    "ğŸ‘€ æ•´é»æ¢ç´¢æç¤º\nåå‘æ¨™è¨˜é¢¨éšªä¸Šå‡ï¼ˆä½†çå‹µä¹Ÿä¸Šå‡ï¼‰ã€‚",
    "âœ¨ æ•´é»æ¢ç´¢æç¤º\nå›è²ç¢ç‰‡å‡ºç¾ç‡çŸ­æš«æå‡ï¼",
    "ğŸŒŒ æ•´é»æ¢ç´¢æç¤º\né¹¿é¹¿æŠ¬é ­çœ‹äº†ä¸€ç§’ï¼šã€ä¾†äº†ã€‚ã€",
    "ğŸ“¡ æ•´é»æ¢ç´¢æç¤º\nä½ è½åˆ°æ¥µè¼•çš„å—¡é³´è²â€”â€”ä¸è¦æŠ¬é ­ã€‚"
  ];

  let echoBoostTimer = 0;
  function triggerHourlyEvent(){
    const msg = hourlyHintPool[(Math.random()*hourlyHintPool.length)|0];
    beep(820, 0.08, "triangle", 0.05);

    echoBoostTimer = 10;
    shards.push(makeSpecialHourlyEchoShard());
    showToast(msg + "\nâœ¨æ•´é»å›è²ç¢ç‰‡å·²åˆ·æ–°ï¼");
  }

  // ===== Game State =====
  const maxDurability = 100;
  const GAME_SECONDS = 60;

  let running = false;
  let timeLeft = GAME_SECONDS;
  let score = 0;
  let combo = 0;
  let maxCombo = 0;
  let breaks = 0;
  let fishHits = 0;

  const pointer = { x: W*0.5, y: H*0.55, pressed: false };

  const net = {
    x: pointer.x, y: pointer.y,
    r: 38,
    down: false,
    durability: maxDurability,
    broken: false,
    cooldown: 0
  };

  const shardTypes = [
    { key:"stardust", name:"æ˜Ÿå±‘", score:1, dmg:[4,7],  speed:1.00, rarity:0.70, color:"rgba(255,244,198,.95)", glow:"rgba(255,255,255,.75)" },
    { key:"prism",    name:"æ£±æ™¶", score:2, dmg:[7,12], speed:1.35, rarity:0.23, color:"rgba(222,210,255,.95)", glow:"rgba(210,255,250,.55)" },
    { key:"echo",     name:"å›è²", score:3, dmg:[10,16],speed:1.55, rarity:0.07, color:"rgba(188,255,235,.95)", glow:"rgba(255,255,255,.85)" }
  ];

  function pickShardType(){
    const boost = echoBoostTimer > 0;
    const weights = shardTypes.map(t => {
      let w = t.rarity;
      if (boost && t.key === "echo") w *= 2.6;
      if (boost && t.key === "stardust") w *= 0.85;
      return w;
    });
    const total = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*total;
    for(let i=0;i<shardTypes.length;i++){
      r -= weights[i];
      if(r <= 0) return shardTypes[i];
    }
    return shardTypes[0];
  }

  function makeShard(){
    const t = pickShardType();
    const baseSp = rand(55, 90) * t.speed;
    const ang = rand(0, Math.PI*2);
    return {
      kind: "shard",
      type: t,
      x: rand(80, W-80),
      y: rand(120, H-90),
      vx: Math.cos(ang)*baseSp,
      vy: Math.sin(ang)*baseSp*0.55,
      r: rand(10, 14),
      tw: rand(0, Math.PI*2),
      alive: true,
      hourly: false
    };
  }

  function makeSpecialHourlyEchoShard(){
    const baseSp = rand(75, 105) * 1.65;
    const ang = rand(0, Math.PI*2);
    return {
      kind: "shard",
      type: {
        key:"echo_hourly",
        name:"å›è²Â·æ•´é»",
        score:4,
        dmg:[12,18],
        speed:1.7,
        rarity:0,
        color:"rgba(210,255,245,.98)",
        glow:"rgba(255,255,255,.92)"
      },
      x: rand(100, W-100),
      y: rand(140, H-110),
      vx: Math.cos(ang)*baseSp,
      vy: Math.sin(ang)*baseSp*0.55,
      r: rand(12, 16),
      tw: rand(0, Math.PI*2),
      alive: true,
      hourly: true
    };
  }

  function makeFish(){
    const baseSp = rand(90, 140);
    const ang = rand(0, Math.PI*2);
    return {
      kind: "fish",
      x: rand(90, W-90),
      y: rand(140, H-90),
      vx: Math.cos(ang)*baseSp,
      vy: Math.sin(ang)*baseSp*0.55,
      r: rand(18, 22),
      wiggle: rand(0, Math.PI*2),
      alive: true
    };
  }

  let shards = [];
  let fish = null;

  const pops = [];
  function spawnPop(x,y,text){ pops.push({x,y,vy:-30,t:0.7,text}); }

  let spawnTimer = 0;
  let fishTimer = 0;

  function resetGame(){
    running = true;
    timeLeft = GAME_SECONDS;
    score = 0; combo = 0; maxCombo = 0;
    breaks = 0; fishHits = 0;

    net.x = W*0.5; net.y = H*0.55;
    net.down = false;
    net.durability = maxDurability;
    net.broken = false;
    net.cooldown = 0;

    shards = Array.from({length: 12}, () => makeShard());
    fish = null;
    pops.length = 0;
    spawnTimer = 0;
    fishTimer = 0;

    echoBoostTimer = 0;

    uiScore.textContent = score;
    uiTime.textContent = timeLeft;
    uiCombo.textContent = combo;
    uiFishCount.textContent = fishHits;
    uiBreaks.textContent = breaks;
    setDurUI();
    setTitleUI();

    showToast("é¹¿é¹¿ï¼šåˆ¥æ€¥ï¼Œç¢ç‰‡æœƒè‡ªå·±é è¿‘ã€‚");
  }

  function endGame(){
    running = false;

    const arr = loadRank();
    arr.push({score, breaks, maxCombo, fishHits, ts: Date.now()});
    arr.sort((a,b) => b.score - a.score || a.breaks - b.breaks || b.maxCombo - a.maxCombo);
    saveRank(arr.slice(0, 20));
    renderRank();

    resultText.innerHTML = `çµç®—ï¼š<b>${score}</b> åˆ†ï½œç ´ç¶² <b>${breaks}</b> æ¬¡ï½œæœ€é«˜é€£æ“Š <b>${maxCombo}</b>ï½œé‡‘é­š <b>${fishHits}</b>ï½œç¨±è™Ÿï¼š<b>${titleFromScore(score)}</b>`;
    overlay.style.display = "grid";
  }

  function titleFromScore(s){
    if(s >= 95) return "è£‚ç¸«è§€æ¸¬å“¡";
    if(s >= 70) return "ç¢ç‰‡æ”¶é›†å¸«";
    if(s >= 45) return "ç†Ÿç·´é¹¿ç²‰";
    if(s >= 25) return "è¦‹ç¿’é¹¿ç²‰";
    return "æ–°æ‰‹é¹¿ç²‰";
  }
  function setTitleUI(){ uiTitle.textContent = titleFromScore(score); }
  function setDurUI(){
    uiDurText.textContent = Math.round(net.durability);
    uiDurBar.style.width = `${(net.durability/maxDurability)*100}%`;
  }

  // ===== Input =====
  function setPointerFromClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    pointer.x = (clientX - rect.left) * (W / rect.width);
    pointer.y = (clientY - rect.top)  * (H / rect.height);
  }
  canvas.addEventListener('mousemove', (e)=> setPointerFromClient(e.clientX, e.clientY));
  canvas.addEventListener('mousedown', (e)=>{ setPointerFromClient(e.clientX,e.clientY); pointer.pressed = true; if(actx && actx.state==="suspended") actx.resume?.(); });
  window.addEventListener('mouseup', ()=> pointer.pressed = false);

  canvas.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    const t = e.touches[0];
    setPointerFromClient(t.clientX, t.clientY);
    pointer.pressed = true;
    if(actx && actx.state==="suspended") actx.resume?.();
  }, {passive:false});
  canvas.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    const t = e.touches[0];
    setPointerFromClient(t.clientX, t.clientY);
  }, {passive:false});
  canvas.addEventListener('touchend', ()=> pointer.pressed = false);

  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==="r"){
      if(running){ resetGame(); beep(520,0.05,"triangle",0.05); }
    }
  });

  // ===== UI buttons =====
  startBtn.addEventListener('click', ()=>{
    overlay.style.display = "none";
    resetGame();
    beep(660,0.06,"triangle",0.06);
  });

  muteBtn.addEventListener('click', ()=>{
    audioOn = !audioOn;
    muteBtn.textContent = `éŸ³æ•ˆï¼š${audioOn ? "é–‹" : "é—œ"}`;
    beep(380,0.05,"sine",0.03);
  });

  resetRankBtn.addEventListener('click', ()=>{
    saveRank([]);
    renderRank();
    beep(320,0.06,"sine",0.03);
  });

  renderRank();

  // ===== Main Loop =====
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    if(toastTimer > 0){
      toastTimer -= dt;
      if(toastTimer <= 0) toast.classList.remove("show");
    }

    if(running){
      timeLeft -= dt;
      if(timeLeft <= 0){
        timeLeft = 0;
        uiTime.textContent = "0";
        endGame();
      }else{
        uiTime.textContent = String(Math.ceil(timeLeft));
      }

      // Hourly event check
      const nowDate = new Date();
      if (nowDate.getMinutes() === 0) {
        const key = hourlyKey(nowDate);
        if (key !== lastHourlyKey && nowDate.getSeconds() <= 10) {
          lastHourlyKey = key;
          if (Math.random() < 0.45) triggerHourlyEvent();
        }
      }
      if(echoBoostTimer > 0) echoBoostTimer -= dt;

      // net follow
      const follow = 12;
      net.x += (pointer.x - net.x) * (1 - Math.exp(-follow*dt));
      net.y += (pointer.y - net.y) * (1 - Math.exp(-follow*dt));
      net.x = clamp(net.x, 60, W-60);
      net.y = clamp(net.y, 110, H-60);

      if (!net.broken && net.cooldown <= 0) net.down = pointer.pressed;
      if (net.cooldown > 0) net.cooldown -= dt;

      // spawn shards
      spawnTimer += dt;
      if(spawnTimer >= 0.6){
        spawnTimer = 0;
        const alive = shards.filter(s => s.alive).length;
        if(alive < 10) shards.push(makeShard());
      }

      // rare fish spawn
      fishTimer += dt;
      if(fishTimer >= 2){
        fishTimer = 0;
        if(!fish && Math.random() < 0.08){
          fish = makeFish();
          showToast("âœ¨é‡‘é­šé©šå–œå‡ºç¾ï¼");
          beep(880,0.08,"triangle",0.05);
        }
      }

      // update shards
      for(const s of shards){
        if(!s.alive) continue;
        s.tw += dt*5;

        s.vx += Math.sin(s.tw)*18*dt;
        s.vy += Math.cos(s.tw*0.9)*12*dt;

        const sp = Math.hypot(s.vx,s.vy);
        const maxSp = 175 * (s.type.speed || 1.0);
        if(sp > maxSp){ s.vx *= maxSp/sp; s.vy *= maxSp/sp; }

        s.x += s.vx*dt;
        s.y += s.vy*dt;

        if (s.x < 70) s.vx += 120*dt;
        if (s.x > W-70) s.vx -= 120*dt;
        if (s.y < 120) s.vy += 90*dt;
        if (s.y > H-70) s.vy -= 90*dt;

        s.x = clamp(s.x, 60, W-60);
        s.y = clamp(s.y, 110, H-60);

        if(net.down && !net.broken){
          const d2 = dist2(net.x, net.y, s.x, s.y);
          const fearR = 140;
          if(d2 < fearR*fearR){
            const d = Math.sqrt(d2) + 0.001;
            const ax = (s.x - net.x)/d;
            const ay = (s.y - net.y)/d;
            const spd = (s.type.speed || 1.0);
            s.vx += ax * 220 * dt * spd;
            s.vy += ay * 160 * dt * spd;
          }
        }

        if(net.down && !net.broken){
          const hit = dist2(net.x, net.y, s.x, s.y) < (net.r + s.r - 6) ** 2;
          if(hit) catchShard(s);
        }
      }

      // update fish
      if(fish && fish.alive){
        fish.wiggle += dt*6;
        fish.vx += Math.sin(fish.wiggle)*10*dt;
        fish.vy += Math.cos(fish.wiggle*0.85)*8*dt;

        const sp = Math.hypot(fish.vx, fish.vy);
        const maxSp = 210;
        if(sp > maxSp){ fish.vx *= maxSp/sp; fish.vy *= maxSp/sp; }

        fish.x += fish.vx*dt;
        fish.y += fish.vy*dt;

        if (fish.x < 70) fish.vx += 160*dt;
        if (fish.x > W-70) fish.vx -= 160*dt;
        if (fish.y < 130) fish.vy += 120*dt;
        if (fish.y > H-70) fish.vy -= 120*dt;

        fish.x = clamp(fish.x, 60, W-60);
        fish.y = clamp(fish.y, 120, H-60);

        if(net.down && !net.broken){
          const hit = dist2(net.x, net.y, fish.x, fish.y) < (net.r + fish.r - 4) ** 2;
          if(hit) catchFish();
        }
      }

      // pops
      for(let i=pops.length-1;i>=0;i--){
        const p = pops[i];
        p.t -= dt;
        p.y += p.vy*dt;
        p.vy -= 10*dt;
        if(p.t <= 0) pops.splice(i,1);
      }

      // broken handling
      if(net.broken && net.cooldown <= 0){
        net.broken = false;
        net.durability = maxDurability;
        setDurUI();
        showToast("é¹¿é¹¿ï¼šæ›æ–°ç¶²äº†ï¼Œç¹¼çºŒæ’ˆã€‚");
        beep(520,0.05,"sine",0.04);
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  function catchShard(s){
    s.alive = false;

    score += s.type.score;
    uiScore.textContent = score;
    setTitleUI();

    combo += 1;
    maxCombo = Math.max(maxCombo, combo);
    uiCombo.textContent = combo;

    net.durability -= rand(s.type.dmg[0], s.type.dmg[1]);

    spawnPop(s.x, s.y, `+${s.type.score}`);

    if(s.type.key === "echo"){
      const pool = [
        "âœ¨æ¢ç´¢æç¤ºï¼šå›è²ç¢ç‰‡åœ¨å¾®å¾®éœ‡å‹•ã€‚",
        "âœ¨æ¢ç´¢æç¤ºï¼šè£‚ç¸«è¨Šè™Ÿâ€¦å¢å¼·äº†ã€‚",
        "âœ¨æ¢ç´¢æç¤ºï¼šç³»çµ±åå‘æ¨™è¨˜é¢¨éšªä¸Šå‡ ğŸ‘€",
        "âœ¨æ¢ç´¢æç¤ºï¼šé¹¿é¹¿ç›¯è‘—å¤©ç©ºè£‚ç¸«çœ‹äº†ä¸€ç§’ã€‚"
      ];
      showToast(pool[(Math.random()*pool.length)|0]);
      beep(740,0.07,"triangle",0.05);
    } else if (s.type.key === "echo_hourly"){
      const pool = [
        "ğŸ•³ï¸æ•´é»å›è²ï¼šä½ æ„Ÿè¦ºåˆ°æ°´é¢ä¸‹æœ‰ã€Œå›æ‡‰ã€ã€‚",
        "ğŸ“¡æ•´é»å›è²ï¼šè¨Šè™ŸæŒ‡å‘åœ’å€ä¸Šç©ºâ€”â€”åˆ¥æŠ¬é ­ã€‚",
        "ğŸ‘€æ•´é»å›è²ï¼šç³»çµ±æ­£åœ¨è¨˜éŒ„é¹¿ç²‰è¡Œç‚ºï¼ˆä¿æŒè‡ªç„¶ï¼‰ã€‚"
      ];
      showToast(pool[(Math.random()*pool.length)|0]);
      beep(920,0.09,"triangle",0.06);
    } else {
      beep(560,0.05,"triangle",0.04);
    }

    if(net.durability <= 0){ breakNet(); return; }
    setDurUI();
  }

  function catchFish(){
    fish.alive = false;
    fish = null;

    score += 5;
    uiScore.textContent = score;
    setTitleUI();

    combo += 2;
    maxCombo = Math.max(maxCombo, combo);
    uiCombo.textContent = combo;

    fishHits += 1;
    uiFishCount.textContent = fishHits;

    net.durability -= rand(14, 22);
    spawnPop(net.x, net.y-10, "+5");

    showToast("ğŸ‰æ’ˆåˆ°é‡‘é­šï¼é¹¿é¹¿ï¼šé‹æ°£ä¸éŒ¯ã€‚");
    beep(980,0.09,"triangle",0.06);

    if(net.durability <= 0){ breakNet(); return; }
    setDurUI();
  }

  function breakNet(){
    net.durability = 0;
    setDurUI();
    net.broken = true;
    net.down = false;
    net.cooldown = 1.2;
    breaks += 1;
    uiBreaks.textContent = breaks;

    combo = 0;
    uiCombo.textContent = combo;

    showToast("é¹¿é¹¿ï¼šç¶²å­ç ´äº†â€¦åˆ¥ç¡¬æ’å•¦ã€‚");
    beep(220,0.10,"sawtooth",0.03);
  }

  // ===== Draw =====
  function draw(){
    ctx.clearRect(0,0,W,H);
    const t = performance.now()/1000;

    // caustics
    ctx.globalAlpha = 0.18;
    for(let i=0;i<6;i++){
      const x = W*(0.15 + i*0.14) + Math.sin(t*0.7 + i)*35;
      const y = 140 + Math.cos(t*0.9 + i*1.2)*22;
      ctx.beginPath();
      ctx.ellipse(x,y, 180, 60, 0.2*Math.sin(t+i), 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // ripples
    ctx.globalAlpha = 0.22;
    for(let i=0;i<7;i++){
      ctx.beginPath();
      const y = 110 + i*22 + Math.sin(t*1.2 + i)*5;
      ctx.ellipse(W/2, y, W*0.46, 10, 0, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.5)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    for(const s of shards){ if(s.alive) drawShard(s); }
    if(fish && fish.alive) drawFish(fish);

    for(const p of pops){
      ctx.save();
      ctx.globalAlpha = clamp(p.t/0.7, 0, 1);
      ctx.font = "18px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.strokeStyle = "rgba(10,18,32,.35)";
      ctx.lineWidth = 3;
      ctx.strokeText(p.text, p.x+2, p.y);
      ctx.fillText(p.text, p.x+2, p.y);
      ctx.restore();
    }

    drawNet();
    drawLuluBadge();

    ctx.globalAlpha = 0.10;
    ctx.fillStyle = "rgba(0,0,0,.9)";
    ctx.fillRect(0,0,W,14);
    ctx.globalAlpha = 1;
  }

  function drawShard(s){
    ctx.save();
    ctx.translate(s.x, s.y);
    const a = performance.now()/700 + s.tw;
    ctx.rotate(a);

    const isHourly = !!s.hourly;

    ctx.globalAlpha = isHourly ? 0.75 : 0.55;
    ctx.beginPath();
    ctx.arc(0,0, s.r*(isHourly?2.5:2.1), 0, Math.PI*2);
    ctx.fillStyle = s.type.glow;
    ctx.fill();

    ctx.globalAlpha = isHourly ? 0.36 : 0.22;
    for(let i=0;i<4;i++){
      const ang = (i/4)*Math.PI/2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(ang)*s.r*2.1, Math.sin(ang)*s.r*2.1);
      ctx.lineTo(Math.cos(ang)*s.r*(isHourly?3.6:3.0), Math.sin(ang)*s.r*(isHourly?3.6:3.0));
      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.lineWidth = isHourly ? 3 : 2;
      ctx.stroke();
    }

    ctx.globalAlpha = 0.97;
    ctx.beginPath();
    ctx.moveTo(0, -s.r);
    ctx.lineTo(s.r, 0);
    ctx.lineTo(0, s.r);
    ctx.lineTo(-s.r, 0);
    ctx.closePath();
    ctx.fillStyle = s.type.color;
    ctx.fill();

    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.moveTo(0, -s.r*0.6);
    ctx.lineTo(s.r*0.45, 0);
    ctx.lineTo(0, s.r*0.6);
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,.88)";
    ctx.fill();

    if(isHourly){
      ctx.globalAlpha = 0.85;
      ctx.beginPath();
      ctx.arc(0,0, s.r*1.35, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.85)";
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawFish(f){
    ctx.save();
    ctx.translate(f.x, f.y);
    const ang = Math.atan2(f.vy, f.vx);
    ctx.rotate(ang);

    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.arc(0,0, f.r*2.2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.fill();

    ctx.globalAlpha = 0.95;
    ctx.beginPath();
    ctx.ellipse(0, 0, f.r*1.35, f.r*0.9, 0, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,170,90,.98)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-f.r*1.25, 0);
    ctx.quadraticCurveTo(-f.r*2.2, -f.r*0.75, -f.r*2.45, 0);
    ctx.quadraticCurveTo(-f.r*2.2,  f.r*0.75, -f.r*1.25, 0);
    ctx.fillStyle = "rgba(255,140,70,.98)";
    ctx.fill();

    ctx.globalAlpha = 0.55;
    ctx.beginPath();
    ctx.ellipse(-f.r*0.15, -f.r*0.55, f.r*0.65, f.r*0.25, 0.3, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,230,210,.9)";
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(f.r*0.75, -f.r*0.15, 3.5, 0, Math.PI*2);
    ctx.fillStyle = "rgba(20,20,20,.9)";
    ctx.fill();

    ctx.restore();
  }

  function drawNet(){
    ctx.save();
    ctx.translate(net.x, net.y);
    const r = net.r + (net.down ? 6 : 0);

    if(net.down){
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.ellipse(8, 10, r*1.15, r*0.55, 0.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,.9)";
      ctx.fill();
    }

    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.arc(0,0, r, 0, Math.PI*2);
    ctx.strokeStyle = net.broken ? "rgba(255,120,120,.92)" : "rgba(255,255,255,.92)";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.globalAlpha = net.down ? 0.58 : 0.38;
    const lines = 7;
    for(let i=0;i<lines;i++){
      const a = (i/lines)*Math.PI;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r);
      ctx.lineTo(Math.cos(a+Math.PI)*r, Math.sin(a+Math.PI)*r);
      ctx.strokeStyle = "rgba(255,255,255,.86)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    const crack = 1 - net.durability/maxDurability;
    if(crack > 0.22){
      ctx.globalAlpha = clamp(crack, 0, 0.9);
      for(let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(rand(-10,10), rand(-10,10));
        ctx.lineTo(rand(-r, r), rand(-r, r));
        ctx.strokeStyle = "rgba(255,255,255,.85)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function roundRectPath(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawLuluBadge(){
    const bx = 18, by = H-18;
    ctx.save();
    ctx.globalAlpha = 0.86;
    roundRectPath(bx, by-96, 340, 78, 18);
    ctx.fillStyle = "rgba(255,255,255,.55)";
    ctx.fill();
    ctx.globalAlpha = 1;

    const gx = bx + 46, gy = by - 56;

    // neck
    ctx.beginPath();
    if(ctx.roundRect){ ctx.roundRect(gx-10, gy+18, 22, 30, 10); }
    else { ctx.rect(gx-10, gy+18, 22, 30); }
    ctx.fillStyle = "rgba(255,220,165,.95)";
    ctx.fill();

    // face
    ctx.beginPath();
    ctx.arc(gx, gy, 18, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,220,165,.98)";
    ctx.fill();

    // horns
    ctx.beginPath();
    ctx.arc(gx-10, gy-18, 5.2, 0, Math.PI*2);
    ctx.arc(gx+10, gy-18, 5.2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,220,165,.95)";
    ctx.fill();

    // spots
    ctx.globalAlpha = 0.92;
    for(let i=0;i<4;i++){
      ctx.beginPath();
      ctx.arc(gx+(i-1.5)*6, gy+(i%2?4:-5), 3.2, 0, Math.PI*2);
      ctx.fillStyle = "rgba(195,135,88,.75)";
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // eyes
    ctx.beginPath();
    ctx.arc(gx-6, gy-2, 2.2, 0, Math.PI*2);
    ctx.arc(gx+6, gy-2, 2.2, 0, Math.PI*2);
    ctx.fillStyle = "rgba(40,40,40,.9)";
    ctx.fill();

    // mouth
    ctx.globalAlpha = 0.7;
    ctx.beginPath();
    ctx.arc(gx, gy+6, 6.5, 0, Math.PI);
    ctx.strokeStyle = "rgba(40,40,40,.7)";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.font = "14px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(10,18,32,.68)";

    let line1 = "é¹¿é¹¿ï¼šç¢ç‰‡åœ¨é£„ï¼Œæ…¢æ…¢ä¾†ã€‚";
    if(net.broken) line1 = "é¹¿é¹¿ï¼šç¶²ç ´äº†ï¼Œç­‰ç­‰æ›æ–°ã€‚";
    else if(net.down) line1 = "é¹¿é¹¿ï¼šå°±ç¾åœ¨ï¼Œä¸‹ç¶²ï¼";
    else if(echoBoostTimer > 0.2) line1 = "é¹¿é¹¿ï¼šæ•´é»è¨Šè™Ÿâ€¦å›è²è®Šå¤šäº†ã€‚";

    ctx.fillText(line1, bx+90, by-64);

    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(10,18,32,.55)";
    const buffTxt = echoBoostTimer > 0.2 ? `æ•´é»å›è²æå‡ï¼š${Math.ceil(echoBoostTimer)}s` : "æç¤ºï¼šæ•´é»å‰ 10 ç§’å¯èƒ½ç™¼å¸ƒæ¢ç´¢æç¤º";
    ctx.fillText(buffTxt, bx+90, by-42);

    ctx.restore();
  }

  // ===== Start =====
  overlay.style.display = "grid";
  renderRank();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
